{"version":3,"sources":["../../node_modules/peerjs/dist sync","components/ErrorFallback.tsx","utils/crypto.ts","utils/url.ts","network/peerUtils.ts","network/room.ts","hooks/useRoom.ts","media/devices.ts","utils/sleep.ts","media/capture.ts","hooks/useFaceImages.ts","media/video.ts","media/audio.ts","hooks/useFaceVideos.ts","components/FaceImages.tsx","hooks/useMomentaryChat.ts","components/MomentaryChat.tsx","components/SingleRoom.tsx","utils/storage.ts","hooks/useAvailableDevices.ts","components/SingleRoomEntrance.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","ErrorFallback","useState","waitSec","setWaitSec","useEffect","setTimeout","window","location","reload","secureRandomId","arrbuf","crypto","getRandomValues","Uint8Array","Array","from","map","b","toString","padStart","join","rand4","Uint16Array","extractRoomIdFromLink","link","hash","URL","slice","URLSearchParams","get","isValidPeerJsId","roomId","peerJsId","startsWith","generatePeerJsId","peerId","getPeerIdFromPeerJsId","Number","split","getPeerIdFromConn","conn","peer","guessSeed","createRoom","updateNetworkStatus","receiveData","disposed","myPeer","lastBroadcastData","connMap","Map","addConn","value","close","set","connected","live","markConnected","isConnected","hasConn","has","delConn","delete","getConnectedPeerJsIds","filter","k","getLivePeerJsIds","forEachConnectedConns","callback","values","forEach","forEachLiveConns","setMedia","media","console","error","getMedia","delMedia","closeAllMedia","clearAll","size","log","clear","createConnectionMap","liveMode","myStream","receiveStream","showConnectedStatus","peerIds","type","connectPeer","connect","serialization","initConnection","broadcastData","data","replaceLastData","peers","livePeers","send","on","payload","info","isArray","callPeer","handlePayload","length","reInitMyPeer","disconnected","Math","floor","random","initMyPeer","index","isSeed","Peer","i","seedId","err","destroy","initMedia","answer","destroyed","reconnect","force","every","oldPeer","call","prevMedia","stream","enableLiveMode","recvStream","warn","disableLiveMode","dispose","roomEntryMap","register","networkStatusListener","dataListener","streamListener","entry","networkStatusListeners","Set","dataListeners","mediaAttachedData","streamListeners","room","status","listener","count","add","MediaStream","attachedData","unregister","useBroadcastData","broadcastDataRef","useRef","useCallback","current","broadcastDataByRegister","dataInfoMap","WeakMap","getDataInfo","useRoomData","isValidData","attachToMedia","setData","undefined","unknownData","setDataInfo","getVideoDeviceInfoList","a","navigator","mediaDevices","enumerateDevices","devices","list","kind","label","deviceId","getAudioDeviceInfoList","sleep","ms","Promise","captureImage","track","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","savedSrcObject","srcObject","revert","videoWidth","videoHeight","constraints","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","max","min","x","y","drawImage","stop","toDataURL","isImageData","userId","image","nickname","message","isFaceInfo","getVideoStream","timer","setInterval","canvasStream","captureStream","clearInterval","getAudioStream","audio","getAudioTracks","applyConstraints","echoCancellation","echoCancellationType","ideal","noiseSuppression","useFaceVideos","videoEnabled","audioEnabled","videoDeviceId","audioDeviceId","enabled","setMyStream","streamMap","setStreamMap","prev","myStreamToSet","streamList","useMemo","Object","useRoomMedia","videoStream","disposeVideo","videoTrack","addTrack","dispatchEvent","Event","removeTrack","audioStream","disposeAudio","audioTrack","item","FaceImage","React","memo","statusMesg","obsoleted","unmuted","hasVideo","setHasVideo","hasAudio","setHasAudio","videoRef","checkStream","addEventListener","removeEventListener","className","opacity","ref","autoPlay","muted","src","alt","title","liveType","myImage","setMyImage","roomImages","setRoomImages","fatalError","setFatalError","faceInfo","imageData","roomImage","received","Date","now","found","find","checkObsoletedImage","twoMinAgo","tenMinAgo","changed","next","loop","clearTimeout","useFaceImages","key","isChatData","chatSeq","chatText","chatInReplyTo","compareReply","countDiff","reactions","ReactionButton","text","onClick","aria-label","MomentaryChatContent","chatList","replyChat","reply","replyTo","replies","chatSeqRef","receivedSeqMap","setChatList","addChatItem","chatData","replyMap","entries","sort","chatItem","sendChat","inReplyTo","useMomentaryChat","setText","onSubmit","event","preventDefault","onChange","target","placeholder","disabled","initialNickname","name","localStorage","getItem","getStringItem","SingleRoom","setNickname","setStatusMesg","searchParams","setRoomIdToUrl","videoDevices","setDevices","deviceInfoList","useVideoDevices","audioDevices","useAudioDevices","setVideoDeviceId","setAudioDeviceId","setLiveType","configOpen","setConfigOpen","networkStatus","useRoomNetworkStatus","appLink","href","replace","JSON","stringify","readOnly","defaultValue","setItem","setStringItem","videoDevice","audioDevice","roomIdFromUrl","getRoomIdFromUrl","SingleRoomEntrance","setRoomId","linkText","setLinkText","ErrorBoundary","state","hasError","children","this","props","Component","App","Boolean","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","then","registration","catch"],"mappings":"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","file":"static/js/main.3652471f.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 28;","import React, { useEffect, useState } from \"react\";\n\nconst ErrorFallback: React.FC = () => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n};\n\nexport default ErrorFallback;\n","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = () => {\n  const arrbuf = window.crypto.getRandomValues(new Uint8Array(32));\n  const arr = Array.from(arrbuf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n","export const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n","import Peer from \"peerjs\";\n\nexport const isValidPeerJsId = (\n  roomId: string,\n  peerJsId: unknown\n): peerJsId is string =>\n  typeof peerJsId === \"string\" && peerJsId.startsWith(`${roomId}_`);\n\nexport const generatePeerJsId = (roomId: string, peerId: number) =>\n  `${roomId}_${peerId}`;\n\nexport const getPeerIdFromPeerJsId = (peerJsId: string) =>\n  Number(peerJsId.split(\"_\")[1]);\n\nexport const getPeerIdFromConn = (conn: Peer.DataConnection) =>\n  getPeerIdFromPeerJsId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected: boolean;\n    live: boolean;\n    media?: Peer.MediaConnection;\n  };\n  const map = new Map<string, Value>();\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, { conn, connected: false, live: false });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerJsId: string) => {\n    const value = map.get(peerJsId);\n    return value ? value.connected : false;\n  };\n\n  const hasConn = (peerJsId: string) => map.has(peerJsId);\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerJsIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const getLivePeerJsIds = () =>\n    Array.from(map.keys()).filter((k) => {\n      const value = map.get(k);\n      return value && value.connected && value.live;\n    });\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachLiveConns = (callback: (conn: Peer.DataConnection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected && value.live) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const setMedia = (media: Peer.MediaConnection) => {\n    const value = map.get(media.peer);\n    if (value && !value.media) {\n      value.media = media;\n    } else {\n      console.error(\"setMedia: invalid value, should not happen\");\n    }\n  };\n\n  const getMedia = (peerJsId: string) => {\n    const value = map.get(peerJsId);\n    return value && value.media;\n  };\n\n  const delMedia = (media: Peer.MediaConnection) => {\n    const value = map.get(media.peer);\n    if (!value) return; // conn is deleted in advance\n    if (value.media === media) {\n      delete value.media;\n    } else {\n      console.error(\"delMedia: invalid value, should not happen\");\n    }\n  };\n\n  const closeAllMedia = () => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.media) {\n        value.media.close();\n        const valueToModify = value;\n        delete valueToModify.media;\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    hasConn,\n    delConn,\n    getConnectedPeerJsIds,\n    getLivePeerJsIds,\n    forEachConnectedConns,\n    forEachLiveConns,\n    setMedia,\n    getMedia,\n    delMedia,\n    closeAllMedia,\n    clearAll,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { rand4 } from \"../utils/crypto\";\nimport {\n  isValidPeerJsId,\n  generatePeerJsId,\n  getPeerIdFromPeerJsId,\n  getPeerIdFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\n\nconst SEED_PEERS = 5; // config\nconst guessSeed = (id: string) => getPeerIdFromPeerJsId(id) < SEED_PEERS;\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerId: number }\n  | { type: \"CONNECTION_CLOSED\"; peerId: number }\n  | { type: \"INITIALIZING_PEER\"; index: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"UNKNOWN_ERROR\" }\n  | { type: \"CONNECTED_PEERS\"; peerIds: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type DataInfo = { peerId: number; liveMode: boolean };\ntype ReceiveData = (data: unknown, info: DataInfo) => void;\ntype ReceiveStream = (\n  stream: MediaStream | null, // null for removing stream\n  info: { peerId: number },\n  close?: () => void\n) => void;\n\nexport const createRoom = (\n  roomId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n  const connMap = createConnectionMap();\n  let liveMode = false;\n  let myStream: MediaStream | null = null;\n  let receiveStream: ReceiveStream | null = null;\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIds = connMap.getConnectedPeerJsIds().map(getPeerIdFromPeerJsId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIds });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id, { serialization: \"json\" });\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown, replaceLastData?: boolean) => {\n    if (disposed) return;\n    if (replaceLastData) {\n      lastBroadcastData = data;\n    }\n    const peers = connMap.getConnectedPeerJsIds();\n    const livePeers = connMap.getLivePeerJsIds();\n    connMap.forEachConnectedConns((conn) => {\n      try {\n        conn.send({ data, peers, liveMode, livePeers });\n      } catch (e) {\n        console.error(\"broadcastData\", e);\n      }\n    });\n  };\n\n  const handlePayload = (conn: Peer.DataConnection, payload: unknown) => {\n    if (disposed) return;\n    try {\n      if (payload && typeof payload === \"object\") {\n        const info: DataInfo = {\n          peerId: getPeerIdFromConn(conn),\n          liveMode: !!(payload as { liveMode?: unknown }).liveMode,\n        };\n        receiveData((payload as { data: unknown }).data, info);\n        if (Array.isArray((payload as { peers: unknown }).peers)) {\n          (payload as { peers: unknown[] }).peers.forEach((peer) => {\n            if (isValidPeerJsId(roomId, peer)) {\n              connectPeer(peer);\n            }\n          });\n        }\n        if (liveMode) {\n          if (info.liveMode && isValidPeerJsId(roomId, conn.peer)) {\n            setTimeout(() => {\n              // XXX I don't know why it only works with setTimeout\n              callPeer(conn.peer);\n            }, 1000);\n          }\n          if (Array.isArray((payload as { livePeers: unknown }).livePeers)) {\n            (payload as { livePeers: unknown[] }).livePeers.forEach((peer) => {\n              if (isValidPeerJsId(roomId, peer)) {\n                callPeer(peer);\n              }\n            });\n          }\n        }\n      }\n    } catch (e) {\n      console.error(\"handlePayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      showConnectedStatus();\n      if (lastBroadcastData) {\n        conn.send({\n          data: lastBroadcastData,\n          peers: connMap.getConnectedPeerJsIds(),\n          liveMode,\n          livePeers: connMap.getLivePeerJsIds(),\n        });\n      }\n    });\n    conn.on(\"data\", (payload: unknown) => handlePayload(conn, payload));\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerId: getPeerIdFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerJsIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIdFromPeerJsId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = 0) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", index });\n    const isSeed = index < SEED_PEERS;\n    const peerId = isSeed ? index : rand4();\n    const id = generatePeerJsId(roomId, peerId);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id);\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = 0; i < SEED_PEERS; i += 1) {\n        const seedId = generatePeerJsId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        lastBroadcastData = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n        peer.destroy();\n      } else {\n        console.error(\"initMyPeer\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\" });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerId: getPeerIdFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"call\", (media) => {\n      if (myPeer !== peer || !myStream) {\n        media.close();\n        return;\n      }\n      console.log(\"new media received\", media);\n      if (initMedia(media)) {\n        media.answer(myStream);\n      }\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        lastBroadcastData = null;\n        setTimeout(initMyPeer, 10 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      const existsAllSeeds = Array.from(Array(SEED_PEERS).keys()).every((i) => {\n        const id = generatePeerJsId(roomId, i);\n        return connMap.isConnected(id);\n      });\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    lastBroadcastData = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const callPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id) return;\n    if (!myStream) return;\n    if (!connMap.isConnected(id)) return;\n    if (connMap.getMedia(id)) return;\n    console.log(\"callPeer\", id);\n    const media = myPeer.call(id, myStream);\n    initMedia(media);\n  };\n\n  const initMedia = (media: Peer.MediaConnection) => {\n    const prevMedia = connMap.getMedia(media.peer);\n    if (prevMedia) {\n      if (\n        myPeer &&\n        getPeerIdFromPeerJsId(myPeer.id) > getPeerIdFromPeerJsId(media.peer)\n      ) {\n        console.log(\"my peer id is bigger, closing media\", media);\n        media.close();\n        return false;\n      }\n      console.log(\"closing prevMedia\", prevMedia);\n      connMap.delMedia(prevMedia);\n      prevMedia.close();\n    }\n    console.log(\"init media\", media);\n    connMap.setMedia(media);\n    media.on(\"stream\", (stream: MediaStream) => {\n      console.log(\"mediaConnection received stream\", media);\n      const info = {\n        peerId: getPeerIdFromPeerJsId(media.peer),\n      };\n      if (receiveStream) receiveStream(stream, info, () => media.close());\n    });\n    media.on(\"close\", () => {\n      console.log(\"mediaConnection closed\", media);\n      const info = {\n        peerId: getPeerIdFromPeerJsId(media.peer),\n      };\n      if (receiveStream) receiveStream(null, info);\n      connMap.delMedia(media);\n    });\n    return true;\n  };\n\n  const enableLiveMode = (stream: MediaStream, recvStream: ReceiveStream) => {\n    if (liveMode) {\n      console.warn(\"liveMode already enabled\");\n      return;\n    }\n    liveMode = true;\n    myStream = stream;\n    receiveStream = recvStream;\n    broadcastData(lastBroadcastData);\n    connMap.forEachLiveConns((conn) => {\n      callPeer(conn.peer);\n    });\n  };\n\n  const disableLiveMode = () => {\n    if (!liveMode) {\n      console.warn(\"liveMode already disabled\");\n      return;\n    }\n    liveMode = false;\n    myStream = null;\n    receiveStream = null;\n    broadcastData(lastBroadcastData);\n    connMap.closeAllMedia();\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    enableLiveMode,\n    disableLiveMode,\n    dispose,\n  };\n};\n","import { useEffect, useState, useCallback, useRef, useMemo } from \"react\";\n\nimport { DataInfo, createRoom, NetworkStatus } from \"../network/room\";\n\ntype NetworkStatusListener = (status: NetworkStatus) => void;\ntype DataListener = (data: unknown, info: DataInfo) => boolean;\ntype StreamListener = (\n  peerId: number,\n  stream: MediaStream | null, // null for removing stream\n  attachedData: unknown\n) => void;\ntype RoomEntry = {\n  room: ReturnType<typeof createRoom>;\n  networkStatusListeners: Set<NetworkStatusListener>;\n  dataListeners: Set<DataListener>;\n  mediaAttachedData: Map<number, unknown>;\n  streamListeners: Set<StreamListener>;\n  myStream?: MediaStream;\n  count: number;\n};\nconst roomEntryMap = new Map<string, RoomEntry>();\nconst register = (\n  roomId: string,\n  networkStatusListener?: NetworkStatusListener,\n  dataListener?: DataListener,\n  streamListener?: StreamListener\n) => {\n  let entry = roomEntryMap.get(roomId);\n  if (!entry) {\n    const networkStatusListeners = new Set<NetworkStatusListener>();\n    const dataListeners = new Set<DataListener>();\n    const mediaAttachedData = new Map<number, unknown>();\n    const streamListeners = new Set<StreamListener>();\n    const updateNetworkStatus = (status: NetworkStatus) => {\n      if (status.type === \"CONNECTION_CLOSED\") {\n        mediaAttachedData.delete(status.peerId);\n      }\n      networkStatusListeners.forEach((listener) => {\n        listener(status);\n      });\n    };\n    const receiveData = (data: unknown, info: DataInfo) => {\n      dataListeners.forEach((listener) => {\n        const attachToMedia = listener(data, info);\n        if (attachToMedia) {\n          mediaAttachedData.set(info.peerId, data);\n        }\n      });\n    };\n    const room = createRoom(roomId, updateNetworkStatus, receiveData);\n    entry = {\n      room,\n      networkStatusListeners,\n      dataListeners,\n      mediaAttachedData,\n      streamListeners,\n      count: 0,\n    };\n    roomEntryMap.set(roomId, entry);\n  }\n  if (networkStatusListener) {\n    entry.networkStatusListeners.add(networkStatusListener);\n  }\n  if (dataListener) {\n    entry.dataListeners.add(dataListener);\n  }\n  if (streamListener) {\n    entry.streamListeners.add(streamListener);\n    if (entry.streamListeners.size === 1) {\n      entry.myStream = new MediaStream();\n      entry.room.enableLiveMode(entry.myStream, (stream, { peerId }, close) => {\n        if (\n          stream &&\n          close &&\n          !(entry as RoomEntry).mediaAttachedData.has(peerId)\n        ) {\n          console.warn(\"stream received too early, closing media:\", peerId);\n          close();\n          return;\n        }\n        const attachedData = (entry as RoomEntry).mediaAttachedData.get(peerId);\n        (entry as RoomEntry).streamListeners.forEach((listener) => {\n          listener(peerId, stream, attachedData);\n        });\n      });\n    }\n  }\n  entry.count += 1;\n  const unregister = () => {\n    if (networkStatusListener) {\n      (entry as RoomEntry).networkStatusListeners.delete(networkStatusListener);\n    }\n    if (dataListener) {\n      (entry as RoomEntry).dataListeners.delete(dataListener);\n    }\n    if (streamListener) {\n      (entry as RoomEntry).streamListeners.delete(streamListener);\n      if ((entry as RoomEntry).streamListeners.size === 0) {\n        delete (entry as RoomEntry).myStream;\n        (entry as RoomEntry).room.disableLiveMode();\n      }\n    }\n    (entry as RoomEntry).count -= 1;\n    if ((entry as RoomEntry).count <= 0) {\n      (entry as RoomEntry).room.dispose();\n      roomEntryMap.delete(roomId);\n    }\n  };\n  return {\n    broadcastData: entry.room.broadcastData,\n    myStream: entry.myStream,\n    unregister,\n  };\n};\n\nexport const useRoomNetworkStatus = (roomId: string) => {\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  if (networkStatus && networkStatus.type === \"UNKNOWN_ERROR\") {\n    throw new Error(\"Network Error\");\n  }\n  useEffect(() => {\n    const { unregister } = register(roomId, updateNetworkStatus);\n    return unregister;\n  }, [roomId]);\n  return networkStatus;\n};\n\ntype BroadcastData = ReturnType<typeof createRoom>[\"broadcastData\"];\n\nexport const useBroadcastData = (roomId: string) => {\n  const broadcastDataRef = useRef<BroadcastData>();\n  const broadcastData = useCallback((...args: Parameters<BroadcastData>) => {\n    if (broadcastDataRef.current) {\n      broadcastDataRef.current(...args);\n    } else {\n      // TODO pending queue\n    }\n  }, []);\n  useEffect(() => {\n    const { broadcastData: broadcastDataByRegister, unregister } = register(\n      roomId\n    );\n    broadcastDataRef.current = broadcastDataByRegister;\n    return unregister;\n  }, [roomId]);\n  return broadcastData;\n};\n\nconst dataInfoMap = new WeakMap<object, DataInfo>();\nexport const getDataInfo = (data: unknown) => {\n  try {\n    return dataInfoMap.get(data as object);\n  } catch (e) {\n    return undefined;\n  }\n};\nconst setDataInfo = (data: unknown, info: DataInfo) => {\n  try {\n    dataInfoMap.set(data as object, info);\n  } catch (e) {\n    // ignore\n  }\n};\n\nexport const useRoomData = <Data>(\n  roomId: string,\n  isValidData: (data: unknown) => boolean,\n  attachToMedia?: boolean\n) => {\n  const [data, setData] = useState<Data>();\n  useEffect(() => {\n    const dataListener = (unknownData: unknown, info: DataInfo) => {\n      if (isValidData(unknownData)) {\n        setDataInfo(unknownData, info);\n        setData(unknownData as Data);\n        return !!attachToMedia;\n      }\n      return false;\n    };\n    const { unregister } = register(roomId, undefined, dataListener);\n    return unregister;\n  }, [roomId, isValidData, attachToMedia]);\n  return data;\n};\n\nexport const useRoomMedia = (roomId: string, enabled: boolean) => {\n  const [myStream, setMyStream] = useState<MediaStream | null>(null);\n  const [streamMap, setStreamMap] = useState<{\n    [peerId: number]: { stream: MediaStream; attachedData: unknown };\n  }>({});\n  useEffect(() => {\n    if (enabled) {\n      const streamListener = (\n        peerId: number,\n        stream: MediaStream | null,\n        attachedData: unknown\n      ) => {\n        if (stream) {\n          setStreamMap((prev) => ({\n            ...prev,\n            [peerId]: { stream, attachedData },\n          }));\n        } else {\n          // remove stream\n          setStreamMap((prev) => {\n            const { [peerId]: removed, ...rest } = prev;\n            return rest;\n          });\n        }\n      };\n      const { myStream: myStreamToSet, unregister } = register(\n        roomId,\n        undefined,\n        undefined,\n        streamListener\n      );\n      setMyStream(myStreamToSet || null);\n      return unregister;\n    }\n    // noot enabled\n    setMyStream(null);\n    setStreamMap({});\n    return undefined;\n  }, [roomId, enabled]);\n  return {\n    myStream,\n    streamList: useMemo(() => Object.values(streamMap), [streamMap]),\n  };\n};\n","type DeviceInfo = {\n  label: string;\n  deviceId: string;\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n\nexport const getAudioDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"audioinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  const savedSrcObject = video.srcObject;\n  const revert = () => {\n    video.srcObject = savedSrcObject;\n  };\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH, revert };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH, revert } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  if (revert) {\n    revert();\n  }\n  track.stop();\n  return canvas.toDataURL(\"image/png\");\n};\n","import { useEffect, useState, useMemo, useRef } from \"react\";\n\nimport { takePhoto } from \"../media/capture\";\nimport { useRoomData, getDataInfo, useBroadcastData } from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n};\ntype ImageData = {\n  userId: string;\n  image: ImageUrl;\n  info: FaceInfo;\n};\ntype RoomImage = ImageData & {\n  received: number; // in milliseconds\n  obsoleted: boolean;\n  liveMode: boolean;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  nickname: string,\n  statusMesg: string,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [fatalError, setFatalError] = useState<Error>();\n  const faceInfo = useRef({ nickname, message: statusMesg });\n  faceInfo.current = { nickname, message: statusMesg };\n\n  if (fatalError) {\n    throw fatalError;\n  }\n\n  const broadcastData = useBroadcastData(roomId);\n  const imageData = useRoomData<ImageData>(roomId, isImageData, true);\n  const roomImage = useMemo(\n    () =>\n      imageData && {\n        ...imageData,\n        received: Date.now(),\n        obsoleted: false,\n        liveMode: !!getDataInfo(imageData)?.liveMode,\n      },\n    [imageData]\n  );\n  if (roomImage) {\n    const found = roomImages.find((item) => item.userId === roomImage.userId);\n    if (!found) {\n      setRoomImages([...roomImages, roomImage]);\n    } else if (found.received !== roomImage.received) {\n      setRoomImages(\n        roomImages.map((item) =>\n          item.userId === roomImage.userId ? roomImage : item\n        )\n      );\n    }\n  }\n\n  useEffect(() => {\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      const tenMinAgo = Date.now() - 10 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev\n          .map((item) => {\n            if (item.received < twoMinAgo && !item.obsoleted) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            if (item.received < tenMinAgo && item.obsoleted) {\n              changed = true;\n              return null;\n            }\n            return item;\n          })\n          .filter((item) => item) as typeof prev;\n\n        return changed ? next : prev;\n      });\n    };\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const data = {\n          userId,\n          image,\n          info: faceInfo.current,\n        };\n        broadcastData(data, true);\n      } catch (e) {\n        console.error(e);\n        setFatalError(e);\n      }\n    };\n    loop();\n    const timer = setInterval(loop, 2 * 60 * 1000);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, deviceId, broadcastData]);\n\n  return {\n    myImage,\n    roomImages,\n  };\n};\n","import { sleep } from \"../utils/sleep\";\n\nexport const getVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(1000);\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  const timer = setInterval(() => {\n    ctx.drawImage(video, x, y, width, height, 0, 0, dstW, dstH);\n  }, 1000 / 30);\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const dispose = () => {\n    video.style.display = \"none\";\n    clearInterval(timer);\n    track.stop();\n  };\n  return {\n    stream: canvasStream,\n    dispose,\n  };\n};\n","export const getAudioStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        audio: { deviceId },\n      }\n    : { audio: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getAudioTracks()[0];\n  await track.applyConstraints({\n    echoCancellation: true,\n    echoCancellationType: { ideal: \"system\" },\n    noiseSuppression: { ideal: true },\n  } as MediaTrackConstraints);\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n","import { useEffect, useMemo } from \"react\";\n\nimport { getVideoStream } from \"../media/video\";\nimport { getAudioStream } from \"../media/audio\";\nimport { useRoomMedia } from \"./useRoom\";\n\nexport const useFaceVideos = (\n  roomId: string,\n  videoEnabled: boolean,\n  audioEnabled: boolean,\n  videoDeviceId?: string,\n  audioDeviceId?: string\n) => {\n  const { myStream, streamList } = useRoomMedia(\n    roomId,\n    videoEnabled || audioEnabled\n  );\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (videoEnabled && myStream) {\n      (async () => {\n        const {\n          stream: videoStream,\n          dispose: disposeVideo,\n        } = await getVideoStream(videoDeviceId);\n        const videoTrack = videoStream.getVideoTracks()[0];\n        myStream.addTrack(videoTrack);\n        myStream.dispatchEvent(new Event(\"customtrack\"));\n        dispose = () => {\n          myStream.removeTrack(videoTrack);\n          disposeVideo();\n          myStream.dispatchEvent(new Event(\"customtrack\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, videoEnabled, videoDeviceId, myStream]);\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (audioEnabled && myStream) {\n      (async () => {\n        const {\n          stream: audioStream,\n          dispose: disposeAudio,\n        } = await getAudioStream(audioDeviceId);\n        const audioTrack = audioStream.getAudioTracks()[0];\n        myStream.addTrack(audioTrack);\n        myStream.dispatchEvent(new Event(\"customtrack\"));\n        dispose = () => {\n          myStream.removeTrack(audioTrack);\n          disposeAudio();\n          myStream.dispatchEvent(new Event(\"customtrack\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, audioEnabled, audioDeviceId, myStream]);\n  const streamMap = useMemo(() => {\n    const map: { [userId: string]: MediaStream } = {};\n    streamList.forEach((item) => {\n      if (typeof item.attachedData === \"object\") {\n        const { userId } = item.attachedData as { userId: unknown };\n        if (typeof userId === \"string\") {\n          map[userId] = item.stream;\n        }\n      }\n    });\n    return map;\n  }, [streamList]);\n  return { myStream, streamMap };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\n\nimport \"./FaceImages.css\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\nconst FaceImage = React.memo<{\n  image?: string;\n  nickname: string;\n  statusMesg: string;\n  obsoleted?: boolean;\n  liveMode?: boolean;\n  stream?: MediaStream;\n  unmuted?: boolean;\n}>(({ image, nickname, statusMesg, obsoleted, liveMode, stream, unmuted }) => {\n  const [hasVideo, setHasVideo] = useState(false);\n  const [hasAudio, setHasAudio] = useState(false);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n    const checkStream = () => {\n      setHasVideo(!!stream && stream.getVideoTracks().length > 0);\n      setHasAudio(!!stream && stream.getAudioTracks().length > 0);\n    };\n    if (stream) {\n      stream.addEventListener(\"addtrack\", checkStream);\n      stream.addEventListener(\"removetrack\", checkStream);\n      stream.addEventListener(\"customtrack\", checkStream);\n    }\n    checkStream();\n    return () => {\n      if (stream) {\n        stream.removeEventListener(\"addtrack\", checkStream);\n        stream.removeEventListener(\"removetrack\", checkStream);\n        stream.removeEventListener(\"customtrack\", checkStream);\n      }\n    };\n  }, [stream]);\n  return (\n    <div className=\"FaceImages-card\" style={{ opacity: obsoleted ? 0.2 : 1 }}>\n      {stream ? (\n        <video\n          className=\"FaceImages-photo\"\n          ref={videoRef}\n          autoPlay\n          muted={!unmuted}\n        />\n      ) : (\n        <img\n          src={image || BLANK_IMAGE}\n          className=\"FaceImages-photo\"\n          alt=\"myself\"\n        />\n      )}\n      <div className=\"FaceImages-name\">{nickname}</div>\n      <div className=\"FaceImages-mesg\">{statusMesg}</div>\n      {hasVideo && hasAudio && (\n        <div className=\"FaceImages-live-indicator\" title=\"Video/Audio On\">\n          &#9672;\n        </div>\n      )}\n      {hasVideo && !hasAudio && (\n        <div className=\"FaceImages-live-indicator\" title=\"Video On\">\n          &#9673;\n        </div>\n      )}\n      {liveMode && !hasVideo && !hasAudio && (\n        <div className=\"FaceImages-live-indicator\" title=\"Video On\">\n          &#9678;\n        </div>\n      )}\n    </div>\n  );\n});\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  liveType: \"off\" | \"video\" | \"video+audio\";\n  videoDeviceId?: string;\n  audioDeviceId?: string;\n};\n\nconst FaceImages: React.FC<Props> = ({\n  roomId,\n  userId,\n  nickname,\n  statusMesg,\n  liveType,\n  videoDeviceId,\n  audioDeviceId,\n}) => {\n  const { myImage, roomImages } = useFaceImages(\n    roomId,\n    userId,\n    nickname,\n    statusMesg,\n    videoDeviceId\n  );\n  const { myStream, streamMap } = useFaceVideos(\n    roomId,\n    liveType === \"video\" || liveType === \"video+audio\",\n    liveType === \"video+audio\",\n    videoDeviceId,\n    audioDeviceId\n  );\n\n  return (\n    <div className=\"FaceImage-container\">\n      <FaceImage\n        image={myImage}\n        nickname={nickname}\n        statusMesg={statusMesg}\n        liveMode={liveType !== \"off\"}\n        stream={myStream || undefined}\n      />\n      {roomImages.map((item) => (\n        <FaceImage\n          key={item.userId}\n          image={item.image}\n          nickname={item.info.nickname}\n          statusMesg={item.info.message}\n          obsoleted={item.obsoleted}\n          liveMode={item.liveMode}\n          stream={streamMap[item.userId]}\n          unmuted={liveType === \"video+audio\"}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default React.memo(FaceImages);\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nconst MAX_CHAT_LIST_SIZE = 100;\n\ntype ChatData = {\n  userId: string;\n  nickname: string;\n  chatSeq: number;\n  chatText: string;\n  chatInReplyTo?: {\n    userId: string;\n    chatSeq: number;\n  };\n};\n\nconst isChatData = (x: unknown): x is ChatData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { chatSeq: unknown }).chatSeq === \"number\" &&\n  typeof (x as { chatText: unknown }).chatText === \"string\" &&\n  (typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"undefined\" ||\n    typeof (x as { chatInReplyTo: { userId: unknown } }).chatInReplyTo\n      .userId === \"string\" ||\n    typeof (x as { chatInReplyTo: { chatSeq: unknown } }).chatInReplyTo\n      .chatSeq === \"number\");\n\ntype Reply = [string, number];\n\ntype ChatItem = {\n  key: string;\n  replyTo: { userId: string; chatSeq: number };\n  nickname: string;\n  text: string;\n  replies: Reply[];\n};\n\nconst compareReply = (a: Reply, b: Reply) => {\n  const countDiff = b[1] - a[1];\n  if (countDiff === 0) {\n    return a[0].length - b[0].length;\n  }\n  return countDiff;\n};\n\nexport const useMomentaryChat = (\n  roomId: string,\n  userId: string,\n  nickname: string\n) => {\n  const chatSeqRef = useRef(1);\n  const receivedSeqMap = useRef(new Map<string, number>());\n  const [chatList, setChatList] = useState<ChatItem[]>([]);\n\n  const addChatItem = useCallback((chatData: ChatData) => {\n    if ((receivedSeqMap.current.get(chatData.userId) || 0) < chatData.chatSeq) {\n      receivedSeqMap.current.set(chatData.userId, chatData.chatSeq);\n    } else {\n      return;\n    }\n    if (chatData.chatInReplyTo) {\n      const { chatText, chatInReplyTo } = chatData;\n      setChatList((prev) =>\n        prev.map((item) => {\n          if (\n            item.replyTo.userId === chatInReplyTo.userId &&\n            item.replyTo.chatSeq === chatInReplyTo.chatSeq\n          ) {\n            const replyMap = new Map(item.replies);\n            replyMap.set(chatText, (replyMap.get(chatText) || 0) + 1);\n            const replies = [...replyMap.entries()];\n            replies.sort(compareReply);\n            return { ...item, replies };\n          }\n          return item;\n        })\n      );\n    } else {\n      const chatItem: ChatItem = {\n        key: `${chatData.userId}_${chatData.chatSeq}`,\n        replyTo: {\n          userId: chatData.userId,\n          chatSeq: chatData.chatSeq,\n        },\n        nickname: chatData.nickname,\n        text: chatData.chatText,\n        replies: [],\n      };\n      setChatList((prev) => [chatItem, ...prev].slice(0, MAX_CHAT_LIST_SIZE));\n    }\n  }, []);\n\n  const broadcastData = useBroadcastData(roomId);\n  const chatData = useRoomData<ChatData>(roomId, isChatData);\n  useEffect(() => {\n    if (chatData) {\n      addChatItem(chatData);\n    }\n  });\n\n  const sendChat = useCallback(\n    (text: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  const replyChat = useCallback(\n    (text: string, inReplyTo: { userId: string; chatSeq: number }) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n        chatInReplyTo: inReplyTo,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  return {\n    chatList,\n    sendChat,\n    replyChat,\n  };\n};\n","import React, { useState } from \"react\";\n\nimport \"./MomentaryChat.css\";\nimport { useMomentaryChat } from \"../hooks/useMomentaryChat\";\n\ntype ChatList = ReturnType<typeof useMomentaryChat>[\"chatList\"];\ntype ReplyChat = ReturnType<typeof useMomentaryChat>[\"replyChat\"];\n\nconst reactions = [\"👍\", \"❤️\", \"😁\", \"😎\", \"🤣\"];\n\nconst ReactionButton: React.FC<{\n  text: string;\n  onClick: (text: string) => void;\n}> = ({ text, onClick }) => (\n  <button type=\"button\" onClick={() => onClick(text)}>\n    <span aria-label=\"Reaction\">{text}</span>\n  </button>\n);\n\nconst MomentaryChatContent = React.memo<{\n  chatList: ChatList;\n  replyChat: ReplyChat;\n}>(({ chatList, replyChat }) => (\n  <ul className=\"MomentaryChat-list\">\n    {chatList.map((item) => {\n      const reply = (text: string) => replyChat(text, item.replyTo);\n      return (\n        <li key={item.key} className=\"MomentaryChat-listPart\">\n          <div className=\"MomentaryChat-listPart-header\">\n            <div className=\"MomentaryChat-iconButton-container\">\n              <div className=\"MomentaryChat-iconButton\">\n                {reactions.map((text) => (\n                  <ReactionButton key={text} text={text} onClick={reply} />\n                ))}\n              </div>\n            </div>\n            <div className=\"MomentaryChat-nickname\">\n              {item.nickname || \"No Name\"}\n            </div>\n          </div>\n          <div>{item.text}</div>\n          {item.replies.map(([text, count]) => (\n            <div className=\"Momentary-icon\">\n              {text} {count}\n            </div>\n          ))}\n        </li>\n      );\n    })}\n  </ul>\n));\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n};\n\nconst MomentaryChat: React.FC<Props> = ({ roomId, userId, nickname }) => {\n  const { chatList, sendChat, replyChat } = useMomentaryChat(\n    roomId,\n    userId,\n    nickname\n  );\n\n  const [text, setText] = useState(\"\");\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      sendChat(text);\n      setText(\"\");\n    }\n  };\n\n  return (\n    <div className=\"MomentaryChat-container\">\n      <form onSubmit={onSubmit}>\n        <input\n          value={text}\n          onChange={(e) => setText(e.target.value)}\n          placeholder=\"Enter chat message\"\n        />\n        <button type=\"submit\" disabled={!text}>\n          Send\n        </button>\n      </form>\n      <MomentaryChatContent chatList={chatList} replyChat={replyChat} />\n    </div>\n  );\n};\n\nexport default React.memo(MomentaryChat);\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./SingleRoom.css\";\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useRoomNetworkStatus } from \"../hooks/useRoom\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport FaceImages from \"./FaceImages\";\nimport MomentaryChat from \"./MomentaryChat\";\n\ntype LiveType = \"off\" | \"video\" | \"video+audio\";\n\ntype Props = {\n  roomId: string;\n  userId: string;\n};\n\nconst initialNickname = getStringItem(\"nickname\");\n\nconst SingleRoom: React.FC<Props> = ({ roomId, userId }) => {\n  const [nickname, setNickname] = useState(initialNickname);\n  const [statusMesg, setStatusMesg] = useState(\"\");\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const videoDevices = useVideoDevices();\n  const audioDevices = useAudioDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>();\n  const [liveType, setLiveType] = useState<LiveType>(\"off\");\n  const [configOpen, setConfigOpen] = useState<boolean>(true);\n\n  const networkStatus = useRoomNetworkStatus(roomId);\n\n  const appLink = `remote-faces://${window.location.href.replace(\n    /^https:\\/\\//,\n    \"\"\n  )}`;\n\n  return (\n    <>\n      <div className=\"SingleRoom-status\">{JSON.stringify(networkStatus)}</div>\n      <div className=\"SingleRoom-room-info\">\n        {configOpen ? (\n          <>\n            <button type=\"button\" onClick={() => setConfigOpen(false)}>\n              Hide config\n            </button>\n            <div>\n              Link to this room:\n              <input value={window.location.href} readOnly />\n              (Share this link with your colleagues)\n              <a href={appLink}>Open App</a>\n            </div>\n            <div className=\"SingleRoom-nickname\">\n              Your Name:{\" \"}\n              <input\n                defaultValue={initialNickname}\n                onChange={(e) => {\n                  setNickname(e.target.value);\n                  setStringItem(\"nickname\", e.target.value);\n                }}\n              />\n            </div>\n            <div className=\"SingleRoom-statusmesg\">\n              Your Status:{\" \"}\n              <input\n                onChange={(e) => {\n                  setStatusMesg(e.target.value);\n                }}\n                placeholder=\"Enter status message\"\n              />\n            </div>\n            <div>\n              Select Camera:{\" \"}\n              <select onChange={(e) => setVideoDeviceId(e.target.value)}>\n                {videoDevices.map((videoDevice) => (\n                  <option\n                    key={videoDevice.deviceId}\n                    value={videoDevice.deviceId}\n                  >\n                    {videoDevice.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              Select Mic:{\" \"}\n              <select onChange={(e) => setAudioDeviceId(e.target.value)}>\n                {audioDevices.map((audioDevice) => (\n                  <option\n                    key={audioDevice.deviceId}\n                    value={audioDevice.deviceId}\n                  >\n                    {audioDevice.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              Live Type:{\" \"}\n              <select onChange={(e) => setLiveType(e.target.value as LiveType)}>\n                <option value=\"off\">Off</option>\n                <option value=\"video\">Video Only</option>\n                <option value=\"video+audio\">Video and Audio</option>\n              </select>\n            </div>\n          </>\n        ) : (\n          <button type=\"button\" onClick={() => setConfigOpen(true)}>\n            Show config\n          </button>\n        )}\n      </div>\n      <FaceImages\n        roomId={roomId}\n        userId={userId}\n        videoDeviceId={videoDeviceId}\n        audioDeviceId={audioDeviceId}\n        nickname={nickname}\n        statusMesg={statusMesg}\n        liveType={liveType}\n      />\n      <MomentaryChat roomId={roomId} userId={userId} nickname={nickname} />\n    </>\n  );\n};\n\nexport default SingleRoom;\n","type StringItemName = \"nickname\" | \"TODO1\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  try {\n    window.localStorage.setItem(name, value);\n  } catch (e) {\n    console.log(\"Failed to save string to localStorage\", e);\n  }\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  try {\n    return window.localStorage.getItem(name) || \"\";\n  } catch (e) {\n    // ignore\n    return \"\";\n  }\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  try {\n    window.localStorage.setItem(name, JSON.stringify(value));\n  } catch (e) {\n    console.log(\"Failed to save json to localStorage\", e);\n  }\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  try {\n    window.localStorage.removeItem(name);\n  } catch (e) {\n    // ignore\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport {\n  getVideoDeviceInfoList,\n  getAudioDeviceInfoList,\n} from \"../media/devices\";\n\ntype VideoDeviceInfoList = ReturnType<\n  typeof getVideoDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<VideoDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n\ntype AudioDeviceInfoList = ReturnType<\n  typeof getAudioDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useAudioDevices = () => {\n  const [devices, setDevices] = useState<AudioDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getAudioDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId } from \"../utils/crypto\";\nimport { getRoomIdFromUrl, extractRoomIdFromLink } from \"../utils/url\";\nimport SingleRoom from \"./SingleRoom\";\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nconst SingleRoomEntrance: React.FC = () => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = () => {\n    setRoomId(secureRandomId());\n  };\n\n  const onEnter = () => {\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-init\">\n      <button type=\"button\" onClick={onCreateNew}>\n        Create a new room\n      </button>\n      OR\n      <input\n        value={linkText}\n        onChange={(e) => setLinkText(e.target.value)}\n        placeholder=\"Enter room link...\"\n      />\n      <button\n        type=\"button\"\n        onClick={onEnter}\n        disabled={!extractRoomIdFromLink(linkText)}\n      >\n        Enter room\n      </button>\n    </div>\n  );\n};\n\nexport default SingleRoomEntrance;\n","import React from \"react\";\n\nimport ErrorFallback from \"./ErrorFallback\";\nimport SingleRoomEntrance from \"./SingleRoomEntrance\";\nimport \"./App.css\";\n\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { hasError } = this.state;\n    if (hasError) return <ErrorFallback />;\n    return children;\n  }\n}\n\nconst App: React.FC = () => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <SingleRoomEntrance />\n    </ErrorBoundary>\n  </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}