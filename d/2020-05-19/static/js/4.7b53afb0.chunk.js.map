{"version":3,"sources":["network/trackUtils.ts","network/room.ts","hooks/useRoom.ts","utils/sleep.ts","utils/types.ts","hooks/useNicknameMap.ts","media/video.ts","media/devices.ts","hooks/useAvailableDevices.ts","../../node_modules/peerjs/dist sync","utils/storage.ts","media/capture.ts","hooks/useFaceImages.ts","media/audio.ts","hooks/useFaceVideos.ts","components/FaceImages.tsx","hooks/useMomentaryChat.ts","utils/emoji.ts","components/WysiwygEditor.tsx","components/MomentaryChat.tsx","components/UserProfile.tsx","components/SingleRoom.tsx"],"names":["setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","a","sleep","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","guessSeed","id","peerIndex","getPeerIndexFromPeerId","roomEntryMap","Map","register","roomId","userId","networkStatusListener","dataListener","trackListener","roomEntryKey","entry","get","networkStatusListeners","Set","dataListeners","trackListeners","room","updateNetworkStatus","receiveData","receiveTrack","disposed","myPeer","lastBroadcastData","connMap","createConnectionMap","mediaTypes","localStream","showConnectedStatus","peerIndexList","getConnectedPeerIds","map","type","connectPeer","disconnected","hasConn","console","log","conn","connect","initConnection","broadcastData","data","replaceLastData","peers","forEachConnectedConns","sendPayload","sendSDP","sdp","SDP","handlePayloadSDP","isObject","offer","peerConnection","setRemoteDescription","syncAllTracks","createAnswer","answer","setLocalDescription","info","Math","random","removeAllTracks","warn","handlePayloadUserId","payloadUserId","setUserId","handlePayloadMediaTypes","payloadMediaTypes","Array","isArray","every","x","setMediaTypes","handlePayloadData","connUserId","getUserId","getPeerIndexFromConn","getMediaTypes","e","handlePayload","encrypted","JSON","decrypt","slice","ROOM_ID_PREFIX_LEN","payload","parse","peer","forEach","isValidPeerId","encrypt","stringify","send","error","isConnected","close","addConn","on","markConnected","buf","iceGatheringState","onicecandidate","scheduledNegotiation","delete","createOffer","event","delConn","length","reInitMyPeer","waitSec","floor","setTimeout","initMyPeer","index","clearAll","isSeed","rand4","generatePeerId","Peer","getServerConfigFromUrl","debug","i","seedId","err","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","trackMediaTypeMap","senders","getSenders","mTypes","getTracks","mType","includes","sender","addTrack","removeTrack","some","transport","acceptMediaTypes","MediaStream","getReceivers","mediaType","forEachConnsAcceptingMedia","name","s","dispose","createRoom","status","listener","count","add","mediaTypeSet","from","prevSize","size","definedEntry","unregister","useRoomNetworkStatus","onNetworkStatus","useState","networkStatus","Error","message","useEffect","ns","useBroadcastData","broadcastDataRef","useRef","useCallback","current","registered","useRoomData","onRoomData","undefined","useRoomMedia","onTrack","functions","setFunctions","result","ms","Promise","resolve","cache","createMapFromCache","nickname","useNicknameMap","nicknameMap","setNicknameMap","findIndex","now","Date","lastUpdated","push","splice","prev","keys","Object","key","getVideoStream","deviceId","constraints","video","navigator","mediaDevices","getUserMedia","stream","getVideoTracks","getFaceVideoStream","document","getElementById","style","display","srcObject","srcW","videoWidth","srcH","videoHeight","canvas","ctx","getContext","width","height","ratio","max","min","y","loop","drawImage","timer","canvasStream","captureStream","clearTimeout","checkVideTrackFaceSize","createElement","videoTrackFaceSizeMap","isVideoTrackFaceSize","promise","getVideoDeviceInfoList","enumerateDevices","devices","list","filter","kind","label","getAudioDeviceInfoList","useVideoDevices","setDevices","deviceInfoList","useAudioDevices","webpackEmptyContext","req","code","module","exports","setStringItem","value","window","localStorage","setItem","getStringItem","getItem","captureImage","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","savedSrcObject","revert","dstW","dstH","toDataURL","isImageData","image","liveMode","isFaceInfo","getAudioStream","audio","getAudioTracks","applyConstraints","echoCancellation","echoCancellationType","ideal","noiseSuppression","addTrackToStream","disposeStream","newStream","MediaStreamTrackEvent","FaceImage","React","memo","statusMesg","obsoleted","speakerOn","className","opacity","ref","videoEle","autoPlay","playsInline","muted","src","alt","title","FaceImages","micOn","videoDeviceId","audioDeviceId","myImage","setMyImage","roomImages","setRoomImages","fatalError","setFatalError","roomImage","received","item","changed","next","checkObsoletedImage","twoMinAgo","tenMinAgo","useFaceImages","videoEnabled","audioEnabled","faceStream","setFaceStream","faceStreamMap","setFaceStreamMap","isMounted","addVideoTrack","removeVideoTrack","addAudioTrack","removeAudioTrack","videoStream","disposeVideo","videoTrack","audioStream","disposeAudio","audioTrack","enabled","onaddtrack","removeEventListener","useFaceVideos","compareReply","b","countDiff","useMomentaryChat","chatSeqRef","receivedSeqMap","chatList","setChatList","addChatItem","chatData","chatSeq","chatInReplyTo","chatText","replyTo","replyMap","replies","entries","sort","time","chatItem","text","toLocaleString","split","sendChat","replyChat","inReplyTo","EmojiPicker","Picker","config","toolbar","balloonToolbar","WysiwygEditor","registerClear","onChange","editor","CustomEditor","onInit","setData","plugins","addItems","character","initEditor","_event","getData","MomentaryChatContentPart","openEmojiPicker","setOpenEmojiPicker","reply","onSelect","native","onClick","dangerouslySetInnerHTML","__html","DOMPurify","sanitize","MomentaryChatContent","onUpdateLayout","chatListRef","useLayoutEffect","scrollHeight","MomentaryChat","containerRef","clearRef","setText","scrollTop","clear","disabled","TextField","initialText","onUpdate","buttonLabel","placeholder","clearOnUpdate","onSubmit","preventDefault","target","UserProfile","initialNickname","emoji","onUpdateNickname","onUpdateStatusMesg","onUpdateEmoji","ScreenShare","lazy","VideoShare","CollabWhiteBoard","initialConfigOpen","initialVideoDeviceId","initialAudioDeviceId","SingleRoom","setNickname","setStatusMesg","setEmoji","setRoomIdToUrl","videoDevices","audioDevices","setVideoDeviceId","setAudioDeviceId","setLiveMode","setMicOn","setSpeakerOn","screenShareMode","setScreenShareMode","videoShareMode","setVideoShareMode","collabWBOpen","setCollabWBOpen","configOpen","setConfigOpen","appLink","location","href","replace","o","readOnly","videoDevice","audioDevice","checked"],"mappings":"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","file":"static/js/4.7b53afb0.chunk.js","sourcesContent":["import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport { rand4, encrypt, decrypt } from \"../utils/crypto\";\nimport { getServerConfigFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport {\n  ROOM_ID_PREFIX_LEN,\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerIndex: number }\n  | { type: \"CONNECTION_CLOSED\"; peerIndex: number }\n  | { type: \"INITIALIZING_PEER\"; peerIndex: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"SERVER_ERROR\" }\n  | { type: \"UNKNOWN_ERROR\"; err: Error }\n  | { type: \"CONNECTED_PEERS\"; peerIndexList: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type PeerInfo = {\n  userId: string;\n  peerIndex: number;\n  mediaTypes: string[];\n};\ntype ReceiveData = (data: unknown, info: PeerInfo) => void;\ntype ReceiveTrack = (track: MediaStreamTrack, info: PeerInfo) => void;\n\nexport const createRoom = (\n  roomId: string,\n  userId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData,\n  receiveTrack: ReceiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n  const connMap = createConnectionMap();\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id || myPeer.disconnected) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown, replaceLastData?: boolean) => {\n    if (disposed) return;\n    if (replaceLastData) {\n      lastBroadcastData = data;\n    }\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendSDP = (conn: Peer.DataConnection, sdp: unknown) => {\n    sendPayload(conn, { SDP: sdp });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (isObject((sdp as { offer: unknown }).offer)) {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(offer as any);\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (isObject((sdp as { answer: unknown }).answer)) {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId as string);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(\n        await decrypt(encrypted, roomId.slice(ROOM_ID_PREFIX_LEN))\n      );\n      console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encrypt(\n        JSON.stringify(payload),\n        roomId.slice(ROOM_ID_PREFIX_LEN)\n      );\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      console.log(\"dataConnection open\", conn);\n      showConnectedStatus();\n      if (lastBroadcastData) {\n        const data = lastBroadcastData;\n        const peers = connMap.getConnectedPeerIds();\n        sendPayload(conn, { userId, data, peers, mediaTypes });\n      }\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => handlePayload(conn, buf));\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    const scheduledNegotiation = new WeakMap<Peer.DataConnection, boolean>();\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (scheduledNegotiation.has(conn)) return;\n      scheduledNegotiation.set(conn, true);\n      await sleep(2000);\n      scheduledNegotiation.delete(conn);\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getMediaTypes(conn),\n        };\n        receiveTrack(\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, {\n      ...(getServerConfigFromUrl() || {}),\n      debug: 3,\n    });\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", index, err);\n        peer.destroy();\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", index, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 20 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n        connMap.forEachConnectedConns((conn) => {\n          const connUserId = connMap.getUserId(conn);\n          if (connUserId) {\n            const info: PeerInfo = {\n              userId: connUserId,\n              peerIndex: getPeerIndexFromPeerId(conn.peer),\n              mediaTypes: connMap.getMediaTypes(conn),\n            };\n            conn.peerConnection.getReceivers().forEach((receiver) => {\n              receiveTrack(\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            });\n          }\n        });\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.peerConnection.addTrack(track, localStream);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.peerConnection.removeTrack(sender);\n        }\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { PeerInfo, createRoom, NetworkStatus } from \"../network/room\";\n\ntype NetworkStatusListener = (status: NetworkStatus) => void;\ntype DataListener = (data: unknown, info: PeerInfo) => void;\ntype TrackListener = {\n  mediaType: string;\n  listener: (track: MediaStreamTrack, info: PeerInfo) => void;\n};\ntype RoomEntry = {\n  room: ReturnType<typeof createRoom>;\n  networkStatusListeners: Set<NetworkStatusListener>;\n  dataListeners: Set<DataListener>;\n  trackListeners: Set<TrackListener>;\n  count: number;\n};\nconst roomEntryMap = new Map<string, RoomEntry>();\nconst register = (\n  roomId: string,\n  userId: string,\n  networkStatusListener?: NetworkStatusListener,\n  dataListener?: DataListener,\n  trackListener?: TrackListener\n) => {\n  const roomEntryKey = `${roomId}_${userId}`;\n  let entry = roomEntryMap.get(roomEntryKey);\n  if (!entry) {\n    const networkStatusListeners = new Set<NetworkStatusListener>();\n    const dataListeners = new Set<DataListener>();\n    const trackListeners = new Set<TrackListener>();\n    const updateNetworkStatus = (status: NetworkStatus) => {\n      networkStatusListeners.forEach((listener) => {\n        listener(status);\n      });\n    };\n    const receiveData = (data: unknown, info: PeerInfo) => {\n      dataListeners.forEach((listener) => {\n        listener(data, info);\n      });\n    };\n    const receiveTrack = (track: MediaStreamTrack, info: PeerInfo) => {\n      trackListeners.forEach(({ listener }) => {\n        listener(track, info);\n      });\n    };\n    const room = createRoom(\n      roomId,\n      userId,\n      updateNetworkStatus,\n      receiveData,\n      receiveTrack\n    );\n    entry = {\n      room,\n      networkStatusListeners,\n      dataListeners,\n      trackListeners,\n      count: 0,\n    };\n    roomEntryMap.set(roomEntryKey, entry);\n  }\n  if (networkStatusListener) {\n    entry.networkStatusListeners.add(networkStatusListener);\n  }\n  if (dataListener) {\n    entry.dataListeners.add(dataListener);\n  }\n  if (trackListener) {\n    const mediaTypeSet = new Set(\n      Array.from(entry.trackListeners).map((x) => x.mediaType)\n    );\n    const prevSize = mediaTypeSet.size;\n    entry.trackListeners.add(trackListener);\n    mediaTypeSet.add(trackListener.mediaType);\n    if (prevSize !== mediaTypeSet.size) {\n      entry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n    }\n  }\n  entry.count += 1;\n  const definedEntry = entry;\n  const unregister = () => {\n    if (networkStatusListener) {\n      definedEntry.networkStatusListeners.delete(networkStatusListener);\n    }\n    if (dataListener) {\n      definedEntry.dataListeners.delete(dataListener);\n    }\n    if (trackListener) {\n      let mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      const prevSize = mediaTypeSet.size;\n      definedEntry.trackListeners.delete(trackListener);\n      mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      if (prevSize !== mediaTypeSet.size) {\n        definedEntry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n      }\n    }\n    definedEntry.count -= 1;\n    if (definedEntry.count <= 0) {\n      definedEntry.room.dispose();\n      roomEntryMap.delete(roomEntryKey);\n    }\n  };\n  return {\n    broadcastData: entry.room.broadcastData,\n    addTrack: entry.room.addTrack,\n    removeTrack: entry.room.removeTrack,\n    unregister,\n  };\n};\n\nexport const useRoomNetworkStatus = (\n  roomId: string,\n  userId: string,\n  onNetworkStatus?: (networkStatus: NetworkStatus) => void\n) => {\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  if (networkStatus && networkStatus.type === \"UNKNOWN_ERROR\") {\n    throw new Error(`Network Error: ${networkStatus.err.message}`);\n  }\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, (ns: NetworkStatus) => {\n      updateNetworkStatus(ns);\n      if (onNetworkStatus) onNetworkStatus(ns);\n    });\n    return unregister;\n  }, [roomId, userId, onNetworkStatus]);\n  return networkStatus;\n};\n\ntype BroadcastData = ReturnType<typeof createRoom>[\"broadcastData\"];\n\nexport const useBroadcastData = (roomId: string, userId: string) => {\n  const broadcastDataRef = useRef<BroadcastData>();\n  const broadcastData = useCallback((...args: Parameters<BroadcastData>) => {\n    if (broadcastDataRef.current) {\n      broadcastDataRef.current(...args);\n    } else {\n      // TODO pending queue\n    }\n  }, []);\n  useEffect(() => {\n    const registered = register(roomId, userId);\n    broadcastDataRef.current = registered.broadcastData;\n    return registered.unregister;\n  }, [roomId, userId]);\n  return broadcastData;\n};\n\nexport const useRoomData = (\n  roomId: string,\n  userId: string,\n  onRoomData: (data: unknown, info: PeerInfo) => void\n) => {\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, undefined, onRoomData);\n    return unregister;\n  }, [roomId, userId, onRoomData]);\n};\n\nexport const useRoomMedia = (\n  roomId: string,\n  userId: string,\n  onTrack: (track: MediaStreamTrack, info: PeerInfo) => void,\n  mediaType?: string\n) => {\n  const [functions, setFunctions] = useState<{\n    addTrack?: (track: MediaStreamTrack) => void;\n    removeTrack?: (track: MediaStreamTrack) => void;\n  }>({});\n  useEffect(() => {\n    if (mediaType) {\n      const result = register(roomId, userId, undefined, undefined, {\n        mediaType,\n        listener: onTrack,\n      });\n      setFunctions({\n        addTrack: (track: MediaStreamTrack) =>\n          result.addTrack(mediaType, track),\n        removeTrack: (track: MediaStreamTrack) =>\n          result.removeTrack(mediaType, track),\n      });\n      return () => {\n        setFunctions({});\n        result.unregister();\n      };\n    }\n    return undefined;\n  }, [roomId, userId, onTrack, mediaType]);\n  return functions;\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","export const isObject = (x: unknown): x is object =>\n  typeof x === \"object\" && x !== null;\n","import { useCallback, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData } from \"./useRoom\";\n\ntype Entry = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n  lastUpdated: number;\n};\nconst cache: Entry[] = [];\nconst TTL = 10 * 60 * 1000; // 10min\n\nconst createMapFromCache = (roomId: string) => {\n  const map: { [userId: string]: string } = {};\n  cache.forEach((entry) => {\n    if (entry.roomId === roomId) {\n      map[entry.userId] = entry.nickname;\n    }\n  });\n  return map;\n};\n\nconst hasInfoNickname = (x: unknown): x is { info: { nickname: string } } =>\n  isObject(x) &&\n  isObject((x as { info: unknown }).info) &&\n  typeof (x as { info: { nickname: unknown } }).info.nickname === \"string\";\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<{\n    [userId: string]: string;\n  }>(() => createMapFromCache(roomId));\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data, info) => {\n        if (!hasInfoNickname(data)) return;\n        const index = cache.findIndex(\n          (entry) => entry.roomId === roomId && entry.userId === info.userId\n        );\n        const now = Date.now();\n        if (index >= 0) {\n          if (cache[index].nickname !== data.info.nickname) {\n            cache[index].nickname = data.info.nickname;\n          }\n          cache[index].lastUpdated = now;\n        } else {\n          cache.push({\n            roomId,\n            userId: info.userId,\n            nickname: data.info.nickname,\n            lastUpdated: now,\n          });\n        }\n        for (let i = cache.length - 1; i >= 0; i -= 1) {\n          if (cache[i].lastUpdated + TTL < now) {\n            cache.splice(i, 1);\n          }\n        }\n        setNicknameMap((prev) => {\n          const map = createMapFromCache(roomId);\n          const keys = Object.keys(map);\n          if (\n            keys.length === Object.keys(prev).length &&\n            keys.every((key) => map[key] === prev[key])\n          ) {\n            return prev;\n          }\n          return map;\n        });\n      },\n      [roomId]\n    )\n  );\n  return nicknameMap;\n};\n","import { sleep } from \"../utils/sleep\";\n\nexport const getVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n\nexport const getFaceVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(1000);\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  let timer: NodeJS.Timeout;\n  const loop = () => {\n    ctx.drawImage(video, x, y, width, height, 0, 0, dstW, dstH);\n    timer = setTimeout(loop, 1000 / 15);\n  };\n  loop();\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const dispose = () => {\n    video.style.display = \"none\";\n    clearTimeout(timer);\n    track.stop();\n    canvasStream.getVideoTracks()[0].stop();\n  };\n  return {\n    stream: canvasStream,\n    dispose,\n  };\n};\n\nconst checkVideTrackFaceSize = async (track: MediaStreamTrack) => {\n  try {\n    const video = document.createElement(\"video\");\n    video.srcObject = new MediaStream([track]);\n    for (let i = 0; i < 50; i += 1) {\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(100);\n      const width = video.videoWidth;\n      const height = video.videoHeight;\n      if (width > 0 && height > 0) {\n        return width === 72 && height === 72;\n      }\n    }\n    return true; // fallback to true\n  } catch (e) {\n    return true; // fallback to true\n  }\n};\n\nconst videoTrackFaceSizeMap = new WeakMap<MediaStreamTrack, Promise<boolean>>();\n\nexport const isVideoTrackFaceSize = (track: MediaStreamTrack) => {\n  if (videoTrackFaceSizeMap.has(track)) {\n    return videoTrackFaceSizeMap.get(track) as Promise<boolean>;\n  }\n  const promise = checkVideTrackFaceSize(track);\n  videoTrackFaceSizeMap.set(track, promise);\n  return promise;\n};\n","type DeviceInfo = {\n  label: string;\n  deviceId: string;\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n\nexport const getAudioDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"audioinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport {\n  getVideoDeviceInfoList,\n  getAudioDeviceInfoList,\n} from \"../media/devices\";\n\ntype VideoDeviceInfoList = ReturnType<\n  typeof getVideoDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<VideoDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n\ntype AudioDeviceInfoList = ReturnType<\n  typeof getAudioDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useAudioDevices = () => {\n  const [devices, setDevices] = useState<AudioDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getAudioDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 64;","type StringItemName =\n  | \"nickname\"\n  | \"config_hidden\"\n  | \"faceimage_video_device_id\"\n  | \"faceimage_audio_device_id\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  try {\n    window.localStorage.setItem(name, value);\n  } catch (e) {\n    console.info(\"Failed to save string to localStorage\", e);\n  }\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  try {\n    return window.localStorage.getItem(name) || \"\";\n  } catch (e) {\n    // ignore\n    return \"\";\n  }\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  try {\n    window.localStorage.setItem(name, JSON.stringify(value));\n  } catch (e) {\n    console.info(\"Failed to save json to localStorage\", e);\n  }\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  try {\n    window.localStorage.removeItem(name);\n  } catch (e) {\n    // ignore\n  }\n};\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  const savedSrcObject = video.srcObject;\n  const revert = () => {\n    video.srcObject = savedSrcObject;\n  };\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH, revert };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH, revert } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  if (revert) {\n    revert();\n  }\n  track.stop();\n  return canvas.toDataURL(\"image/jpeg\");\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { takePhoto } from \"../media/capture\";\nimport { useRoomData, useBroadcastData, useRoomNetworkStatus } from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n  liveMode: boolean;\n};\ntype ImageData = {\n  image: ImageUrl;\n  info: FaceInfo;\n};\ntype RoomImage = ImageData & {\n  userId: string;\n  received: number; // in milliseconds\n  obsoleted: boolean;\n  peerIndex: number;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  isObject(x) &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\" &&\n  typeof (x as { liveMode: unknown }).liveMode === \"boolean\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  isObject(x) &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  nickname: string,\n  statusMesg: string,\n  liveMode: boolean,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [fatalError, setFatalError] = useState<Error>();\n\n  if (fatalError) {\n    throw fatalError;\n  }\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback((data, info) => {\n      if (!isImageData(data)) return;\n      const roomImage = {\n        ...data,\n        userId: info.userId,\n        received: Date.now(),\n        obsoleted: false,\n        peerIndex: info.peerIndex,\n      };\n      setRoomImages((prev) => {\n        const found = prev.find((item) => item.userId === roomImage.userId);\n        if (!found) {\n          return [...prev, roomImage];\n        }\n        return prev.map((item) =>\n          item.userId === roomImage.userId ? roomImage : item\n        );\n      });\n    }, [])\n  );\n\n  useRoomNetworkStatus(\n    roomId,\n    userId,\n    useCallback((networkStatus) => {\n      if (networkStatus && networkStatus.type === \"CONNECTION_CLOSED\") {\n        const { peerIndex } = networkStatus;\n        setRoomImages((prev) => {\n          let changed = false;\n          const next = prev.map((item) => {\n            if (item.peerIndex === peerIndex) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            return item;\n          });\n          return changed ? next : prev;\n        });\n      }\n    }, [])\n  );\n\n  useEffect(() => {\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      const tenMinAgo = Date.now() - 10 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev\n          .map((item) => {\n            if (item.received < twoMinAgo && !item.obsoleted) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            if (item.received < tenMinAgo && item.obsoleted) {\n              changed = true;\n              return null;\n            }\n            return item;\n          })\n          .filter((item) => item) as typeof prev;\n\n        return changed ? next : prev;\n      });\n    };\n    let timer: NodeJS.Timeout;\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const info: FaceInfo = { nickname, message: statusMesg, liveMode };\n        const data: ImageData = {\n          image,\n          info,\n        };\n        broadcastData(data, true);\n      } catch (e) {\n        setFatalError(e);\n      }\n      timer = setTimeout(loop, 2 * 60 * 1000);\n    };\n    loop();\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, deviceId, nickname, statusMesg, liveMode, broadcastData]);\n\n  return {\n    myImage,\n    roomImages,\n  };\n};\n","export const getAudioStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        audio: { deviceId },\n      }\n    : { audio: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getAudioTracks();\n  await track.applyConstraints({\n    echoCancellation: true,\n    echoCancellationType: { ideal: \"system\" },\n    noiseSuppression: { ideal: true },\n  } as MediaTrackConstraints);\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { getFaceVideoStream, isVideoTrackFaceSize } from \"../media/video\";\nimport { getAudioStream } from \"../media/audio\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst addTrackToStream = (\n  track: MediaStreamTrack,\n  stream: MediaStream | null,\n  disposeStream: () => void\n) => {\n  const newStream = stream || new MediaStream();\n  newStream.addTrack(track);\n  newStream.dispatchEvent(new MediaStreamTrackEvent(\"addtrack\", { track }));\n  track.addEventListener(\"ended\", () => {\n    newStream.removeTrack(track);\n    if (newStream.getTracks().length === 0) {\n      disposeStream();\n    }\n  });\n  return newStream;\n};\n\nexport const useFaceVideos = (\n  roomId: string,\n  userId: string,\n  videoEnabled: boolean,\n  audioEnabled: boolean,\n  micOn: boolean,\n  videoDeviceId?: string,\n  audioDeviceId?: string\n) => {\n  const [faceStream, setFaceStream] = useState<MediaStream | null>(null);\n  const [faceStreamMap, setFaceStreamMap] = useState<{\n    [userId: string]: MediaStream;\n  }>({});\n\n  const isMounted = useRef(true);\n  useEffect(() => {\n    isMounted.current = false;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (track.kind === \"video\" && !(await isVideoTrackFaceSize(track))) {\n      return;\n    }\n    const disposeStream = () => {\n      if (isMounted.current) {\n        setFaceStreamMap((prev) => {\n          const { [info.userId]: _, ...rest } = prev;\n          return rest;\n        });\n      }\n    };\n    setFaceStreamMap((prev) => {\n      const stream = prev[info.userId];\n      const newStream = addTrackToStream(track, stream, disposeStream);\n      if (stream === newStream) {\n        return prev;\n      }\n      return { ...prev, [info.userId]: newStream };\n    });\n  }, []);\n\n  const {\n    addTrack: addVideoTrack,\n    removeTrack: removeVideoTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    videoEnabled ? \"faceVideo\" : undefined\n  );\n\n  const {\n    addTrack: addAudioTrack,\n    removeTrack: removeAudioTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    audioEnabled ? \"faceAudio\" : undefined\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (videoEnabled && addVideoTrack && removeVideoTrack) {\n      (async () => {\n        const {\n          stream: videoStream,\n          dispose: disposeVideo,\n        } = await getFaceVideoStream(videoDeviceId);\n        const [videoTrack] = videoStream.getVideoTracks();\n        addVideoTrack(videoTrack);\n        const disposeStream = () => {\n          if (isMounted.current) {\n            setFaceStream(null);\n          }\n        };\n        setFaceStream((prev) =>\n          addTrackToStream(videoTrack, prev, disposeStream)\n        );\n        dispose = () => {\n          removeVideoTrack(videoTrack);\n          disposeVideo();\n          // XXX we need to manually dispatch ended event, why?\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, videoEnabled, videoDeviceId, addVideoTrack, removeVideoTrack]);\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (audioEnabled && addAudioTrack && removeAudioTrack) {\n      (async () => {\n        const {\n          stream: audioStream,\n          dispose: disposeAudio,\n        } = await getAudioStream(audioDeviceId);\n        const [audioTrack] = audioStream.getAudioTracks();\n        addAudioTrack(audioTrack);\n        const disposeStream = () => {\n          if (isMounted.current) {\n            setFaceStream(null);\n          }\n        };\n        setFaceStream((prev) =>\n          addTrackToStream(audioTrack, prev, disposeStream)\n        );\n        dispose = () => {\n          removeAudioTrack(audioTrack);\n          disposeAudio();\n          // XXX we need to manually dispatch ended event, why?\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, audioEnabled, audioDeviceId, addAudioTrack, removeAudioTrack]);\n  useEffect(() => {\n    if (faceStream) {\n      faceStream.getAudioTracks().forEach((track) => {\n        const audioTrack = track;\n        audioTrack.enabled = micOn;\n      });\n      const onaddtrack = (event: MediaStreamTrackEvent) => {\n        const { track } = event;\n        if (track.kind === \"audio\") {\n          track.enabled = micOn;\n        }\n      };\n      faceStream.addEventListener(\"addtrack\", onaddtrack);\n      return () => {\n        faceStream.removeEventListener(\"addtrack\", onaddtrack);\n      };\n    }\n    return undefined;\n  }, [faceStream, micOn]);\n\n  return { faceStream, faceStreamMap };\n};\n","import React from \"react\";\n\nimport \"./FaceImages.css\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\nconst FaceImage = React.memo<{\n  image?: string;\n  nickname: string;\n  statusMesg: string;\n  obsoleted?: boolean;\n  liveMode?: boolean;\n  stream?: MediaStream;\n  speakerOn?: boolean;\n}>(\n  ({ image, nickname, statusMesg, obsoleted, liveMode, stream, speakerOn }) => (\n    <div className=\"FaceImages-card\" style={{ opacity: obsoleted ? 0.2 : 1 }}>\n      {liveMode && !obsoleted && stream ? (\n        <video\n          className=\"FaceImages-photo\"\n          ref={(videoEle) => {\n            if (videoEle && videoEle.srcObject !== stream) {\n              // eslint-disable-next-line no-param-reassign\n              videoEle.srcObject = stream;\n            }\n          }}\n          autoPlay\n          playsInline\n          muted={!speakerOn}\n        />\n      ) : (\n        <img\n          src={image || BLANK_IMAGE}\n          className=\"FaceImages-photo\"\n          alt=\"myself\"\n        />\n      )}\n      <div className=\"FaceImages-name\">{nickname}</div>\n      <div className=\"FaceImages-mesg\">{statusMesg}</div>\n      {liveMode && !obsoleted && stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode On\">\n          &#9673;\n        </div>\n      )}\n      {liveMode && !obsoleted && !stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode Available\">\n          &#9678;\n        </div>\n      )}\n    </div>\n  )\n);\n\nexport const FaceImages = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  liveMode: boolean;\n  micOn: boolean;\n  speakerOn: boolean;\n  videoDeviceId?: string;\n  audioDeviceId?: string;\n}>(\n  ({\n    roomId,\n    userId,\n    nickname,\n    statusMesg,\n    liveMode,\n    micOn,\n    speakerOn,\n    videoDeviceId,\n    audioDeviceId,\n  }) => {\n    const { myImage, roomImages } = useFaceImages(\n      roomId,\n      userId,\n      nickname,\n      statusMesg,\n      liveMode,\n      videoDeviceId\n    );\n    const { faceStream, faceStreamMap } = useFaceVideos(\n      roomId,\n      userId,\n      liveMode,\n      liveMode,\n      micOn,\n      videoDeviceId,\n      audioDeviceId\n    );\n\n    return (\n      <div className=\"FaceImage-container\">\n        <FaceImage\n          image={myImage}\n          nickname={nickname}\n          statusMesg={statusMesg}\n          liveMode={liveMode}\n          stream={faceStream || undefined}\n        />\n        {roomImages.map((item) => (\n          <FaceImage\n            key={item.userId}\n            image={item.image}\n            nickname={item.info.nickname}\n            statusMesg={item.info.message}\n            obsoleted={item.obsoleted}\n            liveMode={item.info.liveMode}\n            stream={(liveMode && faceStreamMap[item.userId]) || undefined}\n            speakerOn={speakerOn}\n          />\n        ))}\n      </div>\n    );\n  }\n);\n","import { useState, useCallback, useRef } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nconst MAX_CHAT_LIST_SIZE = 100;\n\ntype ChatData = {\n  userId: string;\n  nickname: string;\n  chatSeq: number;\n  chatText: string;\n  chatInReplyTo?: {\n    userId: string;\n    chatSeq: number;\n  };\n};\n\nconst isChatData = (x: unknown): x is ChatData =>\n  isObject(x) &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { chatSeq: unknown }).chatSeq === \"number\" &&\n  typeof (x as { chatText: unknown }).chatText === \"string\" &&\n  (typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"undefined\" ||\n    typeof (x as { chatInReplyTo: { userId: unknown } }).chatInReplyTo\n      .userId === \"string\" ||\n    typeof (x as { chatInReplyTo: { chatSeq: unknown } }).chatInReplyTo\n      .chatSeq === \"number\");\n\ntype Reply = [string, number];\n\nexport type ChatItem = {\n  key: string;\n  replyTo: { userId: string; chatSeq: number };\n  nickname: string;\n  text: string;\n  replies: Reply[];\n  time: string;\n};\n\nconst compareReply = (a: Reply, b: Reply) => {\n  const countDiff = b[1] - a[1];\n  if (countDiff === 0) {\n    return a[0].length - b[0].length;\n  }\n  return countDiff;\n};\n\nexport const useMomentaryChat = (\n  roomId: string,\n  userId: string,\n  nickname: string\n) => {\n  const chatSeqRef = useRef(1);\n  const receivedSeqMap = useRef(new Map<string, number>());\n  const [chatList, setChatList] = useState<ChatItem[]>([]);\n\n  const addChatItem = useCallback((chatData: ChatData) => {\n    if ((receivedSeqMap.current.get(chatData.userId) || 0) < chatData.chatSeq) {\n      receivedSeqMap.current.set(chatData.userId, chatData.chatSeq);\n    } else {\n      return;\n    }\n    if (chatData.chatInReplyTo) {\n      const { chatText, chatInReplyTo } = chatData;\n      setChatList((prev) =>\n        prev.map((item) => {\n          if (\n            item.replyTo.userId === chatInReplyTo.userId &&\n            item.replyTo.chatSeq === chatInReplyTo.chatSeq\n          ) {\n            const replyMap = new Map(item.replies);\n            replyMap.set(chatText, (replyMap.get(chatText) || 0) + 1);\n            const replies = [...replyMap.entries()];\n            replies.sort(compareReply);\n            return { ...item, replies };\n          }\n          return item;\n        })\n      );\n    } else {\n      const time = new Date();\n      const chatItem: ChatItem = {\n        key: `${chatData.userId}_${chatData.chatSeq}`,\n        replyTo: {\n          userId: chatData.userId,\n          chatSeq: chatData.chatSeq,\n        },\n        nickname: chatData.nickname,\n        text: chatData.chatText,\n        replies: [],\n        time: time.toLocaleString().split(\" \")[1].slice(0, -3),\n      };\n      setChatList((prev) => [chatItem, ...prev].slice(0, MAX_CHAT_LIST_SIZE));\n    }\n  }, []);\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isChatData(data)) return;\n        addChatItem(data);\n      },\n      [addChatItem]\n    )\n  );\n\n  const sendChat = useCallback(\n    (text: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  const replyChat = useCallback(\n    (text: string, inReplyTo: { userId: string; chatSeq: number }) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n        chatInReplyTo: inReplyTo,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  return {\n    chatList,\n    sendChat,\n    replyChat,\n  };\n};\n","import React from \"react\";\nimport \"emoji-mart/css/emoji-mart.css\";\nimport { BaseEmoji, Picker } from \"emoji-mart\";\n\nexport { Emoji } from \"emoji-mart\";\nexport type EmojiDataType = BaseEmoji;\n\n// we do not support custom emojis\nexport const EmojiPicker = Picker as React.ComponentType<\n  | Omit<React.ComponentProps<typeof Picker>, \"custom\" | \"onSelect\">\n  | {\n      onSelect: (emoji: BaseEmoji) => void;\n    }\n>;\n","// @ts-nocheck XXX ckeditor5 doesn't come with types\n\nimport React from \"react\";\nimport CKEditor from \"@ckeditor/ckeditor5-react\";\nimport CustomEditor from \"@daishi/ckeditor5-build-inline-custom\";\n\nimport \"./WysiwygEditor.css\";\n\nconst config = {\n  toolbar: [\n    \"specialCharacters\",\n    \"|\",\n    \"bold\",\n    \"italic\",\n    \"link\",\n    \"blockQuote\",\n    \"|\",\n    \"imageUpload\",\n    \"insertTable\",\n    \"mediaEmbed\",\n    \"|\",\n    \"undo\",\n    \"redo\",\n  ],\n  balloonToolbar: [\n    \"heading\",\n    \"|\",\n    \"bulletedList\",\n    \"numberedList\",\n    \"indent\",\n    \"outdent\",\n  ],\n};\n\nconst initEditor = (editor) => {\n  editor.plugins.get(\"SpecialCharacters\").addItems(\"Emoji\", [\n    { title: \"smiley face\", character: \"😊\" },\n    { title: \"rocket\", character: \"🚀\" },\n    { title: \"wind blowing face\", character: \"🌬️\" },\n    { title: \"floppy disk\", character: \"💾\" },\n    { title: \"heart\", character: \"❤️\" },\n  ]);\n};\n\nexport const WysiwygEditor = React.memo<{\n  registerClear: (clear: () => void) => void;\n  onChange: (data: string) => void;\n}>(({ registerClear, onChange }) => (\n  <CKEditor\n    editor={CustomEditor}\n    config={config}\n    onInit={(editor) => {\n      registerClear(() => {\n        editor.setData(\"\");\n      });\n      initEditor(editor);\n    }}\n    onChange={(_event, editor) => {\n      const data = editor.getData();\n      onChange(data);\n    }}\n  />\n));\n","import React, { useState, useRef, useLayoutEffect } from \"react\";\nimport DOMPurify from \"dompurify\";\n\nimport \"./MomentaryChat.css\";\nimport { useMomentaryChat, ChatItem } from \"../hooks/useMomentaryChat\";\nimport { EmojiPicker } from \"../utils/emoji\";\nimport { WysiwygEditor } from \"./WysiwygEditor\";\n\ntype ChatList = ReturnType<typeof useMomentaryChat>[\"chatList\"];\ntype ReplyChat = ReturnType<typeof useMomentaryChat>[\"replyChat\"];\n\nconst sanitize = (text: string) => ({\n  __html: DOMPurify.sanitize(text),\n});\n\nconst MomentaryChatContentPart = React.memo<{\n  item: ChatItem;\n  replyChat: ReplyChat;\n}>(({ item, replyChat }) => {\n  const [openEmojiPicker, setOpenEmojiPicker] = useState(false);\n  const reply = (text: string) => replyChat(text, item.replyTo);\n  return (\n    <li key={item.key} className=\"MomentaryChat-listPart\">\n      {openEmojiPicker && (\n        <EmojiPicker\n          onSelect={(e) => {\n            reply(e.native);\n            setOpenEmojiPicker(false);\n          }}\n        />\n      )}\n      <div className=\"MomentaryChat-listPart-header\">\n        <div className=\"MomentaryChat-iconButton-container\">\n          <div className=\"MomentaryChat-iconButton\">\n            <button\n              type=\"button\"\n              onClick={() => {\n                setOpenEmojiPicker(!openEmojiPicker);\n              }}\n            >\n              +\n            </button>\n          </div>\n        </div>\n        <span className=\"MomentaryChat-nickname\">\n          {item.nickname || \"No Name\"}\n        </span>\n        <span className=\"MomentaryChat-time\">{item.time}</span>\n      </div>\n      <div\n        className=\"MomentaryChat-text ck-content\"\n        dangerouslySetInnerHTML={sanitize(item.text)}\n      />\n      {item.replies.map(([text, count]) => (\n        <button\n          key={text}\n          className=\"MomentaryChat-icon\"\n          type=\"button\"\n          onClick={() => reply(text)}\n        >\n          {text} {count}\n        </button>\n      ))}\n    </li>\n  );\n});\n\nconst MomentaryChatContent = React.memo<{\n  chatList: ChatList;\n  replyChat: ReplyChat;\n  onUpdateLayout: (height: number) => void;\n}>(({ chatList, replyChat, onUpdateLayout }) => {\n  const chatListRef = useRef<HTMLUListElement | null>(null);\n  useLayoutEffect(() => {\n    if (chatListRef.current) {\n      onUpdateLayout(chatListRef.current.scrollHeight);\n    }\n  });\n\n  return (\n    <ul className=\"MomentaryChat-list\" ref={chatListRef}>\n      {chatList.map((item) => (\n        <MomentaryChatContentPart\n          key={item.key}\n          item={item}\n          replyChat={replyChat}\n        />\n      ))}\n    </ul>\n  );\n});\n\nexport const MomentaryChat = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const { chatList, sendChat, replyChat } = useMomentaryChat(\n    roomId,\n    userId,\n    nickname\n  );\n\n  const clearRef = useRef<() => void>();\n  const registerClear = (clear: () => void) => {\n    clearRef.current = clear;\n  };\n\n  const [text, setText] = useState(\"\");\n  const onClick = () => {\n    if (text) {\n      sendChat(text);\n      setText(\"\");\n      if (clearRef.current) {\n        clearRef.current();\n      }\n    }\n  };\n\n  return (\n    <div className=\"MomentaryChat-container\" ref={containerRef}>\n      <MomentaryChatContent\n        chatList={chatList}\n        replyChat={replyChat}\n        onUpdateLayout={(height: number) => {\n          if (containerRef.current) {\n            containerRef.current.scrollTop = height;\n          }\n        }}\n      />\n      <div className=\"MomentaryChat-editor\">\n        <WysiwygEditor registerClear={registerClear} onChange={setText} />\n      </div>\n      <div className=\"MomentaryChat-button\">\n        <button type=\"button\" onClick={onClick} disabled={!text}>\n          Send\n        </button>\n      </div>\n    </div>\n  );\n});\n","import React, { useState } from \"react\";\n\nimport \"./UserProfile.css\";\nimport { Emoji, EmojiPicker, EmojiDataType } from \"../utils/emoji\";\n\nconst TextField = React.memo<{\n  initialText: string;\n  onUpdate: (text: string) => void;\n  buttonLabel?: string;\n  placeholder?: string;\n  clearOnUpdate?: boolean;\n}>(({ initialText, onUpdate, buttonLabel, placeholder, clearOnUpdate }) => {\n  const [text, setText] = useState(initialText);\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      onUpdate(text);\n      if (clearOnUpdate) {\n        setText(\"\");\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={onSubmit}>\n      <input\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder={placeholder}\n      />\n      {buttonLabel && (\n        <button type=\"submit\" disabled={!text}>\n          {buttonLabel}\n        </button>\n      )}\n    </form>\n  );\n});\n\nexport const UserProfile = React.memo<{\n  initialNickname: string;\n  emoji: EmojiDataType | null;\n  onUpdateNickname: (e: string) => void;\n  onUpdateStatusMesg: (e: string) => void;\n  onUpdateEmoji: (e: EmojiDataType | null) => void;\n}>(\n  ({\n    initialNickname,\n    emoji,\n    onUpdateNickname,\n    onUpdateStatusMesg,\n    onUpdateEmoji,\n  }) => {\n    const [openEmojiPicker, setOpenEmojiPicker] = useState(false);\n    return (\n      <div className=\"UserProfile-container\">\n        <div className=\"UserProfile-nickname\">\n          <TextField\n            initialText={initialNickname}\n            onUpdate={onUpdateNickname}\n            placeholder=\"Enter your name\"\n            buttonLabel=\"Set\"\n          />\n        </div>\n        <div className=\"UserProfile-status-area\">\n          <div className=\"UserProfile-emoji\">\n            <button\n              type=\"button\"\n              onClick={() => {\n                setOpenEmojiPicker(!openEmojiPicker);\n              }}\n            >\n              {emoji ? <Emoji emoji={emoji} size={10} /> : \":)\"}\n            </button>\n          </div>\n          <div className=\"UserProfile-statusmesg\">\n            <TextField\n              initialText=\"\"\n              onUpdate={onUpdateStatusMesg}\n              placeholder=\"Enter status message\"\n              buttonLabel=\"Set\"\n            />\n          </div>\n          <button\n            type=\"button\"\n            onClick={() => {\n              onUpdateEmoji(null);\n              onUpdateStatusMesg(\"\");\n              setOpenEmojiPicker(false);\n            }}\n          >\n            Clear\n          </button>\n        </div>\n        {openEmojiPicker && (\n          <EmojiPicker\n            onSelect={(e) => {\n              onUpdateEmoji(e);\n              setOpenEmojiPicker(false);\n            }}\n          />\n        )}\n      </div>\n    );\n  }\n);\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./SingleRoom.css\";\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useRoomNetworkStatus } from \"../hooks/useRoom\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { FaceImages } from \"./FaceImages\";\nimport { MomentaryChat } from \"./MomentaryChat\";\nimport { UserProfile } from \"./UserProfile\";\nimport { EmojiDataType } from \"../utils/emoji\";\n\nconst ScreenShare = React.lazy(() => import(\"./ScreenShare\"));\nconst VideoShare = React.lazy(() => import(\"./VideoShare\"));\nconst CollabWhiteBoard = React.lazy(() => import(\"./CollabWhiteBoard\"));\n\nconst initialNickname = getStringItem(\"nickname\");\nconst initialConfigOpen = getStringItem(\"config_hidden\") !== \"true\";\nconst initialVideoDeviceId = getStringItem(\"faceimage_video_device_id\");\nconst initialAudioDeviceId = getStringItem(\"faceimage_audio_device_id\");\n\nexport const SingleRoom = React.memo<{\n  roomId: string;\n  userId: string;\n}>(({ roomId, userId }) => {\n  const [nickname, setNickname] = useState(initialNickname);\n  const [statusMesg, setStatusMesg] = useState(\"\");\n  const [emoji, setEmoji] = useState<EmojiDataType | null>(null);\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const videoDevices = useVideoDevices();\n  const audioDevices = useAudioDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState(initialVideoDeviceId);\n  const [audioDeviceId, setAudioDeviceId] = useState(initialAudioDeviceId);\n  const [liveMode, setLiveMode] = useState(false);\n  const [micOn, setMicOn] = useState(false);\n  const [speakerOn, setSpeakerOn] = useState(false);\n  const [screenShareMode, setScreenShareMode] = useState(false);\n  const [videoShareMode, setVideoShareMode] = useState(false);\n  const [collabWBOpen, setCollabWBOpen] = useState(false);\n\n  const [configOpen, setConfigOpen] = useState(initialConfigOpen);\n  useEffect(() => {\n    setStringItem(\"config_hidden\", configOpen ? \"false\" : \"true\");\n  }, [configOpen]);\n\n  const networkStatus = useRoomNetworkStatus(roomId, userId);\n  useNicknameMap(roomId, userId); // to enable caching\n\n  const appLink = `remote-faces://${window.location.href.replace(\n    /^https:\\/\\//,\n    \"\"\n  )}`;\n\n  return (\n    <>\n      <div className=\"SingleRoom-body\">\n        <FaceImages\n          roomId={roomId}\n          userId={userId}\n          videoDeviceId={videoDeviceId}\n          audioDeviceId={audioDeviceId}\n          nickname={nickname}\n          statusMesg={`${emoji?.native || \"\"}${statusMesg}`}\n          liveMode={liveMode}\n          micOn={micOn}\n          speakerOn={speakerOn}\n        />\n        <div className=\"SingleRoom-2nd-column\">\n          <UserProfile\n            initialNickname={initialNickname}\n            emoji={emoji}\n            onUpdateNickname={(text) => {\n              setNickname(text);\n              setStringItem(\"nickname\", text);\n            }}\n            onUpdateStatusMesg={(text) => {\n              setStatusMesg(text);\n            }}\n            onUpdateEmoji={(e) => {\n              setEmoji(e);\n            }}\n          />\n          <div>\n            <button\n              type=\"button\"\n              className=\"SingleRoom-config-toggle\"\n              onClick={() => setConfigOpen((o) => !o)}\n            >\n              Setting{configOpen ? <>&#9660;</> : <>&#9654;</>}\n            </button>\n            {configOpen && (\n              <div className=\"SingleRoom-config\">\n                <div>\n                  Link to this room:\n                  <input value={window.location.href} readOnly />\n                  (Share this link with your colleagues)\n                  <a href={appLink}>Open App</a>\n                </div>\n                <div>\n                  Select Camera:{\" \"}\n                  <select\n                    value={videoDeviceId}\n                    onChange={(e) => {\n                      setVideoDeviceId(e.target.value);\n                      setStringItem(\n                        \"faceimage_video_device_id\",\n                        e.target.value\n                      );\n                    }}\n                  >\n                    {videoDevices.map((videoDevice) => (\n                      <option\n                        key={videoDevice.deviceId}\n                        value={videoDevice.deviceId}\n                      >\n                        {videoDevice.label}\n                      </option>\n                    ))}\n                  </select>\n                </div>\n                <div>\n                  Select Mic:{\" \"}\n                  <select\n                    value={audioDeviceId}\n                    onChange={(e) => {\n                      setAudioDeviceId(e.target.value);\n                      setStringItem(\n                        \"faceimage_audio_device_id\",\n                        e.target.value\n                      );\n                    }}\n                  >\n                    {audioDevices.map((audioDevice) => (\n                      <option\n                        key={audioDevice.deviceId}\n                        value={audioDevice.deviceId}\n                      >\n                        {audioDevice.label}\n                      </option>\n                    ))}\n                  </select>\n                </div>\n                <div>\n                  Live Mode:{\" \"}\n                  <button type=\"button\" onClick={() => setLiveMode((x) => !x)}>\n                    {liveMode ? \"Disable\" : \"Enable\"}\n                  </button>\n                  {liveMode && <>&#10004;</>}\n                  {liveMode && (\n                    <div>\n                      <label>\n                        <input\n                          type=\"checkbox\"\n                          checked={micOn}\n                          onChange={(e) => setMicOn(e.target.checked)}\n                        />\n                        Mic On\n                      </label>\n                      <label>\n                        <input\n                          type=\"checkbox\"\n                          checked={speakerOn}\n                          onChange={(e) => setSpeakerOn(e.target.checked)}\n                        />\n                        Speaker On\n                      </label>\n                    </div>\n                  )}\n                </div>\n                <div>\n                  Screen Share:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setScreenShareMode((x) => !x)}\n                  >\n                    {screenShareMode ? \"Close\" : \"Open\"}\n                  </button>\n                  {screenShareMode && <>&#10004;</>}\n                </div>\n                <div>\n                  Video Share:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setVideoShareMode((x) => !x)}\n                  >\n                    {videoShareMode ? \"Close\" : \"Open\"}\n                  </button>\n                  {videoShareMode && <>&#10004;</>}\n                </div>\n                <div>\n                  Collab White Board:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setCollabWBOpen((x) => !x)}\n                  >\n                    {collabWBOpen ? \"Close\" : \"Open\"}\n                  </button>\n                  {collabWBOpen && <>&#10004;</>}\n                </div>\n                <div className=\"SingleRoom-status\">\n                  {JSON.stringify(networkStatus)}\n                </div>\n              </div>\n            )}\n          </div>\n          <MomentaryChat roomId={roomId} userId={userId} nickname={nickname} />\n        </div>\n        <div className=\"SingleRoom-3rd-column\">\n          {screenShareMode && (\n            <ScreenShare roomId={roomId} userId={userId} nickname={nickname} />\n          )}\n          {videoShareMode && (\n            <VideoShare roomId={roomId} userId={userId} nickname={nickname} />\n          )}\n          {collabWBOpen && <CollabWhiteBoard roomId={roomId} />}\n        </div>\n      </div>\n    </>\n  );\n});\n\nexport default SingleRoom;\n"],"sourceRoot":""}