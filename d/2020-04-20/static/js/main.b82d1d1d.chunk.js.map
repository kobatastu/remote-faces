{"version":3,"sources":["../../node_modules/peerjs/dist sync","components/ErrorFallback.tsx","utils/crypto.ts","utils/url.ts","network/peerUtils.ts","network/room.ts","hooks/useRoom.ts","utils/sleep.ts","media/capture.ts","hooks/useFaceImages.ts","components/FaceImages.tsx","hooks/useMomentaryChat.ts","components/MomentaryChat.tsx","components/SingleRoom.tsx","utils/storage.ts","hooks/useVideoDevices.ts","components/SingleRoomEntrance.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","ErrorFallback","useState","waitSec","setWaitSec","useEffect","setTimeout","window","location","reload","secureRandomId","arrbuf","crypto","getRandomValues","Uint8Array","Array","from","map","b","toString","padStart","join","rand4","Uint16Array","extractRoomIdFromLink","link","hash","URL","slice","URLSearchParams","get","generatePeerJsId","roomId","peerId","getPeerIdFromPeerJsId","peerJsId","Number","split","getPeerIdFromConn","conn","peer","guessSeed","createRoom","updateNetworkStatus","receiveData","disposed","myPeer","lastBroadcastData","connMap","Map","addConn","set","connected","markConnected","value","isConnected","hasConn","has","delConn","delete","getConnectedPeerJsIds","filter","k","forEachConnectedConns","callback","values","forEach","clearAll","size","console","log","clear","createConnectionMap","showConnectedStatus","peerIds","type","connectPeer","connect","serialization","initConnection","close","on","send","data","peers","payload","isArray","startsWith","isValidPeerJsId","error","handlePayload","length","reInitMyPeer","disconnected","Math","floor","random","initMyPeer","index","isSeed","Peer","i","seedId","err","destroy","destroyed","reconnect","force","every","oldPeer","broadcastData","replaceLastData","dispose","roomEntryMap","register","networkStatusListener","dataListener","entry","networkStatusListeners","Set","dataListeners","room","status","listener","count","add","unregister","useBroadcastData","broadcastDataRef","useRef","useCallback","current","broadcastDataByRegister","useRoomData","isValidData","setData","undefined","_peerId","unknownData","sleep","ms","Promise","captureImage","stream","track","a","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","srcObject","videoWidth","videoHeight","deviceId","constraints","navigator","mediaDevices","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","max","min","x","y","drawImage","stop","toDataURL","getVideoDeviceInfoList","enumerateDevices","devices","list","kind","label","isImageData","userId","image","nickname","message","isFaceInfo","info","React","memo","statusMesg","myImage","setMyImage","roomImages","setRoomImages","fatalError","setFatalError","faceInfo","imageData","roomImage","useMemo","received","Date","now","obsoleted","found","find","item","checkObsoletedImage","twoMinAgo","prev","changed","next","loop","timer","setInterval","clearTimeout","useFaceImages","className","src","alt","key","opacity","isChatData","chatSeq","chatText","chatInReplyTo","compareReply","countDiff","reactions","ReactionButton","text","onClick","aria-label","MomentaryChatContent","chatList","replyChat","reply","replyTo","JSON","stringify","replies","chatSeqRef","receivedSeqMap","setChatList","addChatItem","chatData","replyMap","entries","sort","chatItem","sendChat","inReplyTo","useMomentaryChat","setText","onSubmit","event","preventDefault","onChange","target","disabled","initialNickname","name","localStorage","getItem","getStringItem","SingleRoom","setNickname","setStatusMesg","searchParams","setRoomIdToUrl","setDeviceId","configOpen","setConfigOpen","videoDevices","setDevices","deviceInfoList","useVideoDevices","networkStatus","useRoomNetworkStatus","appLink","href","replace","readOnly","defaultValue","setItem","setStringItem","placeholder","videoDevice","roomIdFromUrl","getRoomIdFromUrl","SingleRoomEntrance","setRoomId","linkText","setLinkText","ErrorBoundary","state","hasError","children","this","props","Component","App","Boolean","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","then","registration","catch"],"mappings":"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","file":"static/js/main.b82d1d1d.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 24;","import React, { useEffect, useState } from \"react\";\n\nconst ErrorFallback: React.FC = () => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n};\n\nexport default ErrorFallback;\n","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = () => {\n  const arrbuf = window.crypto.getRandomValues(new Uint8Array(32));\n  const arr = Array.from(arrbuf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n","export const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n","import Peer from \"peerjs\";\n\nexport const isValidPeerJsId = (\n  roomId: string,\n  peerJsId: unknown\n): peerJsId is string =>\n  typeof peerJsId === \"string\" && peerJsId.startsWith(`${roomId}_`);\n\nexport const generatePeerJsId = (roomId: string, peerId: number) =>\n  `${roomId}_${peerId}`;\n\nexport const getPeerIdFromPeerJsId = (peerJsId: string) =>\n  Number(peerJsId.split(\"_\")[1]);\n\nexport const getPeerIdFromConn = (conn: Peer.DataConnection) =>\n  getPeerIdFromPeerJsId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected: boolean;\n  };\n  const map = new Map<string, Value>();\n  const addConn = (conn: Peer.DataConnection) => {\n    map.set(conn.peer, { conn, connected: false });\n  };\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n  const isConnected = (peerJsId: string) => {\n    const value = map.get(peerJsId);\n    return value ? value.connected : false;\n  };\n  const hasConn = (peerJsId: string) => map.has(peerJsId);\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n  const getConnectedPeerJsIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    hasConn,\n    delConn,\n    getConnectedPeerJsIds,\n    forEachConnectedConns,\n    clearAll,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { rand4 } from \"../utils/crypto\";\nimport {\n  isValidPeerJsId,\n  generatePeerJsId,\n  getPeerIdFromPeerJsId,\n  getPeerIdFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\n\nconst SEED_PEERS = 5; // config\nconst guessSeed = (id: string) => getPeerIdFromPeerJsId(id) < SEED_PEERS;\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerId: number }\n  | { type: \"INITIALIZING_PEER\"; index: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"UNKNOWN_ERROR\" }\n  | { type: \"CONNECTED_PEERS\"; peerIds: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\ntype ReceiveData = (peerId: number, data: unknown) => void;\n\nexport const createRoom = (\n  roomId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n  const connMap = createConnectionMap();\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIds = connMap.getConnectedPeerJsIds().map(getPeerIdFromPeerJsId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIds });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id, { serialization: \"json\" });\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown, replaceLastData?: boolean) => {\n    if (disposed) return;\n    if (replaceLastData) {\n      lastBroadcastData = data;\n    }\n    const peers = connMap.getConnectedPeerJsIds();\n    connMap.forEachConnectedConns((conn) => {\n      try {\n        conn.send({ data, peers });\n      } catch (e) {\n        console.error(\"broadcastData\", e);\n      }\n    });\n  };\n\n  const handlePayload = (conn: Peer.DataConnection, payload: unknown) => {\n    if (disposed) return;\n    try {\n      const peerId = getPeerIdFromConn(conn);\n      if (payload && typeof payload === \"object\") {\n        receiveData(peerId, (payload as { data: unknown }).data);\n        if (Array.isArray((payload as { peers: unknown }).peers)) {\n          (payload as { peers: unknown[] }).peers.forEach((peer) => {\n            if (isValidPeerJsId(roomId, peer)) {\n              connectPeer(peer);\n            }\n          });\n        }\n      }\n    } catch (e) {\n      console.error(\"handlePayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      showConnectedStatus();\n      if (lastBroadcastData) {\n        conn.send({\n          data: lastBroadcastData,\n          peers: connMap.getConnectedPeerJsIds(),\n        });\n      }\n    });\n    conn.on(\"data\", (payload: unknown) => handlePayload(conn, payload));\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      showConnectedStatus();\n      if (connMap.getConnectedPeerJsIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIdFromPeerJsId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = 0) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", index });\n    const isSeed = index < SEED_PEERS;\n    const peerId = isSeed ? index : rand4();\n    const id = generatePeerJsId(roomId, peerId);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id);\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = 0; i < SEED_PEERS; i += 1) {\n        const seedId = generatePeerJsId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n        peer.destroy();\n      } else {\n        console.error(\"initMyPeer\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\" });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) return;\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerId: getPeerIdFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 10 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      const existsAllSeeds = Array.from(Array(SEED_PEERS).keys()).every((i) => {\n        const id = generatePeerJsId(roomId, i);\n        return connMap.isConnected(id);\n      });\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    dispose,\n  };\n};\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { createRoom, NetworkStatus } from \"../network/room\";\n\ntype NetworkStatusListener = (status: NetworkStatus) => void;\ntype DataListener = (peerId: number, data: unknown) => void;\ntype RoomEntry = {\n  room: ReturnType<typeof createRoom>;\n  networkStatusListeners: Set<NetworkStatusListener>;\n  dataListeners: Set<DataListener>;\n  count: number;\n};\nconst roomEntryMap = new Map<string, RoomEntry>();\nconst register = (\n  roomId: string,\n  networkStatusListener?: NetworkStatusListener,\n  dataListener?: DataListener\n) => {\n  let entry = roomEntryMap.get(roomId);\n  if (!entry) {\n    const networkStatusListeners = new Set<NetworkStatusListener>();\n    const dataListeners = new Set<DataListener>();\n    const updateNetworkStatus = (status: NetworkStatus) => {\n      networkStatusListeners.forEach((listener) => {\n        listener(status);\n      });\n    };\n    const receiveData = (peerId: number, data: unknown) => {\n      dataListeners.forEach((listener) => {\n        listener(peerId, data);\n      });\n    };\n    const room = createRoom(roomId, updateNetworkStatus, receiveData);\n    entry = { room, networkStatusListeners, dataListeners, count: 0 };\n    roomEntryMap.set(roomId, entry);\n  }\n  if (networkStatusListener) {\n    entry.networkStatusListeners.add(networkStatusListener);\n  }\n  if (dataListener) {\n    entry.dataListeners.add(dataListener);\n  }\n  entry.count += 1;\n  const unregister = () => {\n    if (networkStatusListener) {\n      (entry as RoomEntry).networkStatusListeners.delete(networkStatusListener);\n    }\n    if (dataListener) {\n      (entry as RoomEntry).dataListeners.delete(dataListener);\n    }\n    (entry as RoomEntry).count -= 1;\n    if ((entry as RoomEntry).count <= 0) {\n      (entry as RoomEntry).room.dispose();\n      roomEntryMap.delete(roomId);\n    }\n  };\n  return {\n    broadcastData: entry.room.broadcastData,\n    unregister,\n  };\n};\n\nexport const useRoomNetworkStatus = (roomId: string) => {\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  if (networkStatus && networkStatus.type === \"UNKNOWN_ERROR\") {\n    throw new Error(\"Network Error\");\n  }\n  useEffect(() => {\n    const { unregister } = register(roomId, updateNetworkStatus);\n    return unregister;\n  }, [roomId]);\n  return networkStatus;\n};\n\ntype BroadcastData = ReturnType<typeof createRoom>[\"broadcastData\"];\n\nexport const useBroadcastData = (roomId: string) => {\n  const broadcastDataRef = useRef<BroadcastData>();\n  const broadcastData = useCallback((...args: Parameters<BroadcastData>) => {\n    if (broadcastDataRef.current) {\n      broadcastDataRef.current(...args);\n    } else {\n      // TODO pending queue\n    }\n  }, []);\n  useEffect(() => {\n    const { broadcastData: broadcastDataByRegister, unregister } = register(\n      roomId\n    );\n    broadcastDataRef.current = broadcastDataByRegister;\n    return unregister;\n  }, [roomId]);\n  return broadcastData;\n};\n\nexport const useRoomData = <Data>(\n  roomId: string,\n  isValidData: (data: unknown) => boolean\n) => {\n  const [data, setData] = useState<Data>();\n  useEffect(() => {\n    const dataListener = (_peerId: number, unknownData: unknown) => {\n      if (isValidData(unknownData)) {\n        setData(unknownData as Data);\n      }\n    };\n    const { unregister } = register(roomId, undefined, dataListener);\n    return unregister;\n  }, [roomId, isValidData]);\n  return data;\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  track.stop();\n  return canvas.toDataURL(\"image/png\");\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  type VideoDeviceInfo = {\n    label: string;\n    deviceId: string;\n  };\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: VideoDeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","import { useEffect, useState, useMemo, useRef } from \"react\";\n\nimport { takePhoto } from \"../media/capture\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n};\ntype ImageData = {\n  userId: string;\n  image: ImageUrl;\n  info: FaceInfo;\n};\ntype RoomImage = ImageData & {\n  received: number; // in milliseconds\n  obsoleted: boolean;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  nickname: string,\n  statusMesg: string,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [fatalError, setFatalError] = useState<Error>();\n  const faceInfo = useRef({ nickname, message: statusMesg });\n  faceInfo.current = { nickname, message: statusMesg };\n\n  if (fatalError) {\n    throw fatalError;\n  }\n\n  const broadcastData = useBroadcastData(roomId);\n  const imageData = useRoomData<ImageData>(roomId, isImageData);\n  const roomImage = useMemo(\n    () =>\n      imageData && {\n        ...imageData,\n        received: Date.now(),\n        obsoleted: false,\n      },\n    [imageData]\n  );\n  if (roomImage) {\n    const found = roomImages.find((item) => item.userId === roomImage.userId);\n    if (!found) {\n      setRoomImages([...roomImages, roomImage]);\n    } else if (found.received !== roomImage.received) {\n      setRoomImages(\n        roomImages.map((item) =>\n          item.userId === roomImage.userId ? roomImage : item\n        )\n      );\n    }\n  }\n\n  useEffect(() => {\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev.map((item) => {\n          if (item.received < twoMinAgo && !item.obsoleted) {\n            changed = true;\n            return { ...item, obsoleted: true };\n          }\n          return item;\n        });\n        return changed ? next : prev;\n      });\n    };\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const data = {\n          userId,\n          image,\n          info: faceInfo.current,\n        };\n        broadcastData(data, true);\n      } catch (e) {\n        console.error(e);\n        setFatalError(e);\n      }\n    };\n    loop();\n    const timer = setInterval(loop, 2 * 60 * 1000);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, deviceId, broadcastData]);\n\n  return {\n    myImage,\n    roomImages,\n  };\n};\n","import React from \"react\";\n\nimport \"./FaceImages.css\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  deviceId?: string;\n};\n\nconst FaceImages: React.FC<Props> = ({\n  roomId,\n  userId,\n  nickname,\n  statusMesg,\n  deviceId,\n}) => {\n  const { myImage, roomImages } = useFaceImages(\n    roomId,\n    userId,\n    nickname,\n    statusMesg,\n    deviceId\n  );\n\n  return (\n    <div>\n      <div className=\"FaceImages-card\">\n        <img\n          src={myImage || BLANK_IMAGE}\n          className=\"FaceImages-photo\"\n          alt=\"myself\"\n        />\n        <div className=\"FaceImages-name\">{nickname}</div>\n        <div className=\"FaceImages-mesg\">{statusMesg}</div>\n      </div>\n      {roomImages.map((item) => (\n        <div\n          key={item.userId}\n          className=\"FaceImages-card\"\n          style={{ opacity: item.obsoleted ? 0.2 : 1 }}\n        >\n          <img src={item.image} className=\"FaceImages-photo\" alt=\"friend\" />\n          <div className=\"FaceImages-name\">{item.info.nickname}</div>\n          <div className=\"FaceImages-mesg\">{item.info.message}</div>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default React.memo(FaceImages);\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nconst MAX_CHAT_LIST_SIZE = 100;\n\ntype ChatData = {\n  userId: string;\n  nickname: string;\n  chatSeq: number;\n  chatText: string;\n  chatInReplyTo?: {\n    userId: string;\n    chatSeq: number;\n  };\n};\n\nconst isChatData = (x: unknown): x is ChatData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { chatSeq: unknown }).chatSeq === \"number\" &&\n  typeof (x as { chatText: unknown }).chatText === \"string\" &&\n  (typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"undefined\" ||\n    typeof (x as { chatInReplyTo: { userId: unknown } }).chatInReplyTo\n      .userId === \"string\" ||\n    typeof (x as { chatInReplyTo: { chatSeq: unknown } }).chatInReplyTo\n      .chatSeq === \"number\");\n\ntype Reply = [string, number];\n\ntype ChatItem = {\n  key: string;\n  replyTo: { userId: string; chatSeq: number };\n  nickname: string;\n  text: string;\n  replies: Reply[];\n};\n\nconst compareReply = (a: Reply, b: Reply) => {\n  const countDiff = b[1] - a[1];\n  if (countDiff === 0) {\n    return a[0].length - b[0].length;\n  }\n  return countDiff;\n};\n\nexport const useMomentaryChat = (\n  roomId: string,\n  userId: string,\n  nickname: string\n) => {\n  const chatSeqRef = useRef(1);\n  const receivedSeqMap = useRef(new Map<string, number>());\n  const [chatList, setChatList] = useState<ChatItem[]>([]);\n\n  const addChatItem = useCallback((chatData: ChatData) => {\n    if ((receivedSeqMap.current.get(chatData.userId) || 0) < chatData.chatSeq) {\n      receivedSeqMap.current.set(chatData.userId, chatData.chatSeq);\n    } else {\n      return;\n    }\n    if (chatData.chatInReplyTo) {\n      const { chatText, chatInReplyTo } = chatData;\n      setChatList((prev) =>\n        prev.map((item) => {\n          if (\n            item.replyTo.userId === chatInReplyTo.userId &&\n            item.replyTo.chatSeq === chatInReplyTo.chatSeq\n          ) {\n            const replyMap = new Map(item.replies);\n            replyMap.set(chatText, (replyMap.get(chatText) || 0) + 1);\n            const replies = [...replyMap.entries()];\n            replies.sort(compareReply);\n            return { ...item, replies };\n          }\n          return item;\n        })\n      );\n    } else {\n      const chatItem: ChatItem = {\n        key: `${chatData.userId}_${chatData.chatSeq}`,\n        replyTo: {\n          userId: chatData.userId,\n          chatSeq: chatData.chatSeq,\n        },\n        nickname: chatData.nickname,\n        text: chatData.chatText,\n        replies: [],\n      };\n      setChatList((prev) => [chatItem, ...prev].slice(0, MAX_CHAT_LIST_SIZE));\n    }\n  }, []);\n\n  const broadcastData = useBroadcastData(roomId);\n  const chatData = useRoomData<ChatData>(roomId, isChatData);\n  useEffect(() => {\n    if (chatData) {\n      addChatItem(chatData);\n    }\n  });\n\n  const sendChat = useCallback(\n    (text: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  const replyChat = useCallback(\n    (text: string, inReplyTo: { userId: string; chatSeq: number }) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n        chatInReplyTo: inReplyTo,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  return {\n    chatList,\n    sendChat,\n    replyChat,\n  };\n};\n","import React, { useState } from \"react\";\n\nimport \"./MomentaryChat.css\";\nimport { useMomentaryChat } from \"../hooks/useMomentaryChat\";\n\ntype ChatList = ReturnType<typeof useMomentaryChat>[\"chatList\"];\ntype ReplyChat = ReturnType<typeof useMomentaryChat>[\"replyChat\"];\n\nconst reactions = [\"👍\", \"❤️\", \"😁\", \"😎\", \"🤣\", \"Send a PR!\"];\n\nconst ReactionButton: React.FC<{\n  text: string;\n  onClick: (text: string) => void;\n}> = ({ text, onClick }) => (\n  <button type=\"button\" onClick={() => onClick(text)}>\n    <span aria-label=\"Reaction\">{text}</span>\n  </button>\n);\n\nconst MomentaryChatContent = React.memo<{\n  chatList: ChatList;\n  replyChat: ReplyChat;\n}>(({ chatList, replyChat }) => (\n  <ul className=\"MomentaryChat-list\">\n    {chatList.map((item) => {\n      const reply = (text: string) => replyChat(text, item.replyTo);\n      return (\n        <li key={item.key}>\n          {item.nickname} - {item.text} {JSON.stringify(item.replies)}\n          {reactions.map((text) => (\n            <ReactionButton key={text} text={text} onClick={reply} />\n          ))}\n        </li>\n      );\n    })}\n  </ul>\n));\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n};\n\nconst MomentaryChat: React.FC<Props> = ({ roomId, userId, nickname }) => {\n  const { chatList, sendChat, replyChat } = useMomentaryChat(\n    roomId,\n    userId,\n    nickname\n  );\n\n  const [text, setText] = useState(\"\");\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      sendChat(text);\n      setText(\"\");\n    }\n  };\n\n  return (\n    <div className=\"MomentaryChat-container\">\n      <form onSubmit={onSubmit}>\n        <input value={text} onChange={(e) => setText(e.target.value)} />\n        <button type=\"submit\" disabled={!text}>\n          Send\n        </button>\n      </form>\n      <MomentaryChatContent chatList={chatList} replyChat={replyChat} />\n    </div>\n  );\n};\n\nexport default React.memo(MomentaryChat);\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./SingleRoom.css\";\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useRoomNetworkStatus } from \"../hooks/useRoom\";\nimport { useVideoDevices } from \"../hooks/useVideoDevices\";\nimport FaceImages from \"./FaceImages\";\nimport MomentaryChat from \"./MomentaryChat\";\n\ntype Props = {\n  roomId: string;\n  userId: string;\n};\n\nconst initialNickname = getStringItem(\"nickname\");\n\nconst SingleRoom: React.FC<Props> = ({ roomId, userId }) => {\n  const [nickname, setNickname] = useState(initialNickname);\n  const [statusMesg, setStatusMesg] = useState(\"\");\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const [deviceId, setDeviceId] = useState<string>();\n  const [configOpen, setConfigOpen] = useState<boolean>(true);\n  const videoDevices = useVideoDevices();\n\n  const networkStatus = useRoomNetworkStatus(roomId);\n\n  const appLink = `remote-faces://${window.location.href.replace(\n    /^https:\\/\\//,\n    \"\"\n  )}`;\n\n  return (\n    <>\n      <div className=\"SingleRoom-status\">{JSON.stringify(networkStatus)}</div>\n      {configOpen ? (\n        <div className=\"SingleRoom-room-info\">\n          <button type=\"button\" onClick={() => setConfigOpen(false)}>\n            Hide config\n          </button>\n          <div>\n            Link to this room:\n            <input value={window.location.href} readOnly />\n            (Share this link with your colleagues)\n            <a href={appLink}>Open App</a>\n          </div>\n          <div className=\"SingleRoom-nickname\">\n            Your Name:{\" \"}\n            <input\n              defaultValue={initialNickname}\n              onChange={(e) => {\n                setNickname(e.target.value);\n                setStringItem(\"nickname\", e.target.value);\n              }}\n            />\n          </div>\n          <div className=\"SingleRoom-statusmesg\">\n            Your Status:{\" \"}\n            <input\n              onChange={(e) => {\n                setStatusMesg(e.target.value);\n              }}\n              placeholder=\"Enter status message\"\n            />\n          </div>\n          <div>\n            Select Camera:{\" \"}\n            <select onChange={(e) => setDeviceId(e.target.value)}>\n              {videoDevices.map((videoDevice) => (\n                <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n                  {videoDevice.label}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n      ) : (\n        <button type=\"button\" onClick={() => setConfigOpen(true)}>\n          Show config\n        </button>\n      )}\n      <FaceImages\n        roomId={roomId}\n        userId={userId}\n        deviceId={deviceId}\n        nickname={nickname}\n        statusMesg={statusMesg}\n      />\n      <MomentaryChat roomId={roomId} userId={userId} nickname={nickname} />\n    </>\n  );\n};\n\nexport default SingleRoom;\n","type StringItemName = \"nickname\" | \"TODO1\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  try {\n    window.localStorage.setItem(name, value);\n  } catch (e) {\n    console.log(\"Failed to save string to localStorage\", e);\n  }\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  try {\n    return window.localStorage.getItem(name) || \"\";\n  } catch (e) {\n    // ignore\n    return \"\";\n  }\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  try {\n    window.localStorage.setItem(name, JSON.stringify(value));\n  } catch (e) {\n    console.log(\"Failed to save json to localStorage\", e);\n  }\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  try {\n    window.localStorage.removeItem(name);\n  } catch (e) {\n    // ignore\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport { getVideoDeviceInfoList } from \"../media/capture\";\n\ntype DeviceInfoList = ReturnType<typeof getVideoDeviceInfoList> extends Promise<\n  infer T\n>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<DeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId } from \"../utils/crypto\";\nimport { getRoomIdFromUrl, extractRoomIdFromLink } from \"../utils/url\";\nimport SingleRoom from \"./SingleRoom\";\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nconst SingleRoomEntrance: React.FC = () => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = () => {\n    setRoomId(secureRandomId());\n  };\n\n  const onEnter = () => {\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-init\">\n      <button type=\"button\" onClick={onCreateNew}>\n        Create a new room\n      </button>\n      OR\n      <input\n        value={linkText}\n        onChange={(e) => setLinkText(e.target.value)}\n        placeholder=\"Enter room link...\"\n      />\n      <button\n        type=\"button\"\n        onClick={onEnter}\n        disabled={!extractRoomIdFromLink(linkText)}\n      >\n        Enter room\n      </button>\n    </div>\n  );\n};\n\nexport default SingleRoomEntrance;\n","import React from \"react\";\n\nimport ErrorFallback from \"./ErrorFallback\";\nimport SingleRoomEntrance from \"./SingleRoomEntrance\";\nimport \"./App.css\";\n\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { hasError } = this.state;\n    if (hasError) return <ErrorFallback />;\n    return children;\n  }\n}\n\nconst App: React.FC = () => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <SingleRoomEntrance />\n    </ErrorBoundary>\n  </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}